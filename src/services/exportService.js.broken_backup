import { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } from 'docx'
import html2canvas from 'html2canvas'
import jsPDF from 'jspdf'
// TEMPORARILY DISABLED: epub-gen is a Node.js library and cannot run in browser
// import EPub from 'epub-gen'

class ExportService {
  async generateDOCX(compiledContent) {
    try {
      // Extract dynamic metadata - NO HARDCODED FALLBACKS
      const title = compiledContent.userInput?.book_title || 
                    compiledContent.userInput?.story_title || 
                    'Untitled'
      const author = compiledContent.userInput?.author_name || 'Unknown Author'
      
      // Transform compiledContent.sections to flat chapter array
      let chapters = []
      const rawSections = compiledContent.sections || []
      
      rawSections.forEach((section, idx) => {
        if (Array.isArray(section.content)) {
          // Multi-chapter array - flatten it
          section.content.forEach(ch => {
            chapters.push({
              title: ch.title || `Chapter ${chapters.length + 1}`,
              content: ch.content || '',
              metadata: { chapterNumber: ch.chapter || chapters.length + 1 }
            })
          })
        } else if (typeof section.content === 'string') {
          // Extract chapter title from content string
          const content = section.content
          let chapterTitle = `Chapter ${idx + 1}`
          
          // Parse title from content (e.g., "Chapter 1: Title Name")
          const titleMatch = content.match(/^(?:Chapter|CHAPTER)\s*\d+:?\s*(.+?)(?:\n|$)/m)
          if (titleMatch && titleMatch[1]) {
            chapterTitle = titleMatch[1].trim().replace(/\*\*/g, '').trim()
          }
          
          chapters.push({
            title: chapterTitle,
            content: content,
            metadata: { chapterNumber: idx + 1 }
          })
        }
      })
      
      // Fallback: use raw content if no chapters extracted
      if (chapters.length === 0 && compiledContent.content) {
        chapters = [{
          title: title,
          content: compiledContent.content,
          metadata: { chapterNumber: 1 }
        }]
      }
      
      console.log(`üìù Generating DOCX: "${title}" by ${author}`)
      console.log(`üìù Extracted ${chapters.length} chapters:`, chapters.map(c => c.title))
      
      // Build document children array
      const documentChildren = []
      
      // ============================================================
      // TITLE PAGE
      // ============================================================
      documentChildren.push(
        new Paragraph({
          children: [
            new TextRun({
              text: title,
              bold: true,
              size: 48
            })
          ],
          heading: HeadingLevel.TITLE,
          alignment: AlignmentType.CENTER,
          spacing: {
            after: 400
          }
        }),
        
        new Paragraph({
          children: [
            new TextRun({
              text: `by ${author}`,
              italics: true,
              size: 32
            })
          ],
          alignment: AlignmentType.CENTER,
          spacing: {
            after: 600
          }
        }),
        
        new Paragraph({
          children: [
            new TextRun({
              text: `Generated on: ${new Date().toLocaleDateString()}`,
              size: 20
            })
          ],
          alignment: AlignmentType.CENTER,
          spacing: {
            after: 800
          }
        })
      )
      
      // ============================================================
      // TABLE OF CONTENTS
      // ============================================================
      documentChildren.push(
        new Paragraph({
          children: [
            new TextRun({
              text: 'Table of Contents',
              bold: true,
              size: 36
            })
          ],
          heading: HeadingLevel.HEADING_1,
          alignment: AlignmentType.CENTER,
          spacing: {
            before: 400,
            after: 300
          },
          pageBreakBefore: true
        })
      )
      
      // Add TOC entries
      chapters.forEach((chapter, index) => {
        const chapterTitle = chapter.title || `Chapter ${index + 1}`
        const chapterNum = chapter.metadata?.chapterNumber || (index + 1)
        
        documentChildren.push(
          new Paragraph({
            children: [
              new TextRun({
                text: `${chapterNum}. ${chapterTitle}`,
                size: 24
              })
            ],
            spacing: {
              after: 100
            }
          })
        )
      })
      
      // ============================================================
      // CHAPTERS
      // ============================================================
      chapters.forEach((chapter, index) => {
        const chapterTitle = chapter.title || `Chapter ${index + 1}`
        const chapterNum = chapter.metadata?.chapterNumber || (index + 1)
        const chapterContent = chapter.content || ''
        
        console.log(`üìñ DOCX Chapter ${chapterNum}: "${chapterTitle}", content length: ${chapterContent.length}, content type: ${typeof chapterContent}`)
        
        if (!chapterContent || !chapterContent.trim()) {
          console.error(`‚ùå DOCX: Chapter ${chapterNum} has EMPTY or INVALID content!`)
          return // Skip empty chapters
        }
        
        // Chapter heading with page break
        documentChildren.push(
          new Paragraph({
            children: [
              new TextRun({
                text: `CHAPTER ${chapterNum}`,
                bold: true,
                size: 24,
                color: '666666'
              })
            ],
            alignment: AlignmentType.CENTER,
            spacing: {
              before: 200,
              after: 100
            },
            pageBreakBefore: true
          }),
          
          new Paragraph({
            children: [
              new TextRun({
                text: chapterTitle,
                bold: true,
                size: 32
              })
            ],
            heading: HeadingLevel.HEADING_1,
            alignment: AlignmentType.CENTER,
            spacing: {
              after: 400
            }
          })
        )
        
        // Chapter content - split into paragraphs
        const paragraphs = chapterContent.split('\n\n').filter(p => p.trim())
        
        paragraphs.forEach((paragraph) => {
          documentChildren.push(
            new Paragraph({
              children: [
                new TextRun({
                  text: paragraph.trim(),
                  size: 24
                })
              ],
              spacing: {
                after: 200
              },
              alignment: AlignmentType.JUSTIFIED
            })
          )
        })
      })
      
      // ============================================================
      // ABOUT THE AUTHOR (if available)
      // ============================================================
      const aboutAuthor = compiledContent.userInput?.about_author
      if (aboutAuthor && aboutAuthor.trim()) {
        documentChildren.push(
          new Paragraph({
            children: [
              new TextRun({
                text: 'About the Author',
                bold: true,
                size: 32
              })
            ],
            heading: HeadingLevel.HEADING_1,
            alignment: AlignmentType.CENTER,
            spacing: {
              before: 400,
              after: 300
            },
            pageBreakBefore: true
          }),
          
          new Paragraph({
            children: [
              new TextRun({
                text: aboutAuthor,
                size: 24
              })
            ],
            spacing: {
              after: 200
            },
            alignment: AlignmentType.JUSTIFIED
          })
        )
      }
      
      // Create document
      const doc = new Document({
        sections: [{
          properties: {
            page: {
              margin: {
                top: 1440,    // 1 inch
                right: 1440,
                bottom: 1440,
                left: 1440
              }
            }
          },
          children: documentChildren
        }]
      })
      
      console.log('‚úÖ DOCX document structure created')
      
      // Generate blob
      const blob = await Packer.toBlob(doc)
      
      console.log('‚úÖ DOCX generated successfully, size:', blob.size, 'bytes')
      
      // Return URL for consistency with PDF and EPUB
      return URL.createObjectURL(blob)
      
    } catch (error) {
      console.error('‚ùå DOCX generation failed:', error.message)
      console.error('Error details:', error)
      
      // DO NOT FALLBACK - REPORT THE ERROR
      throw new Error(`DOCX generation failed: ${error.message}`)
    }
  }
  
  async generatePDF(compiledContent) {
    try {
      // Extract dynamic metadata - NO HARDCODED FALLBACKS
      const title = compiledContent.userInput?.book_title || 
                    compiledContent.userInput?.story_title || 
                    'Untitled'
      const author = compiledContent.userInput?.author_name || 'Unknown Author'
      
      // Get typography preferences
      const fontFamily = compiledContent.userInput?.font_family || 
                        compiledContent.userInput?.typography_combo?.split(',')[0] || 
                        'Times New Roman'
      
      // Transform compiledContent.sections to flat chapter array
      let chapters = []
      const rawSections = compiledContent.sections || []
      
      rawSections.forEach((section, idx) => {
        if (Array.isArray(section.content)) {
          // Multi-chapter array - flatten it
          section.content.forEach(ch => {
            chapters.push({
              title: ch.title || `Chapter ${chapters.length + 1}`,
              content: ch.content || '',
              metadata: { chapterNumber: ch.chapter || chapters.length + 1 }
            })
          })
        } else if (typeof section.content === 'string') {
          // Extract chapter title from content string
          const content = section.content
          let chapterTitle = `Chapter ${idx + 1}`
          
          // Parse title from content (e.g., "Chapter 1: Title Name")
          const titleMatch = content.match(/^(?:Chapter|CHAPTER)\s*\d+:?\s*(.+?)(?:\n|$)/m)
          if (titleMatch && titleMatch[1]) {
            chapterTitle = titleMatch[1].trim().replace(/\*\*/g, '').trim()
          }
          
          chapters.push({
            title: chapterTitle,
            content: content,
            metadata: { chapterNumber: idx + 1 }
          })
        }
      })
      
      // Fallback: use raw content if no chapters extracted
      if (chapters.length === 0 && compiledContent.content) {
        chapters = [{
          title: title,
          content: compiledContent.content,
          metadata: { chapterNumber: 1 }
        }]
      }
      
      console.log(`üìÑ Generating PDF: "${title}" by ${author}`)
      console.log(`üìÑ Extracted ${chapters.length} chapters:`, chapters.map(c => c.title))
      
      // Initialize PDF with professional settings
      const pdf = new jsPDF({
        orientation: 'portrait',
        unit: 'mm',
        format: 'a5', // Standard book size
        compress: true
      })
      
      const pageWidth = pdf.internal.pageSize.getWidth()
      const pageHeight = pdf.internal.pageSize.getHeight()
      const margin = 15
      const contentWidth = pageWidth - (margin * 2)
      const maxY = pageHeight - margin - 10 // Reserve space for footer
      
      let currentPage = 1
      let yPosition = margin
      
      // Helper function to add page numbers and footers
      const addPageFooter = (pageNum) => {
        pdf.setFontSize(9)
        pdf.setFont('helvetica', 'normal')
        pdf.setTextColor(128, 128, 128)
        pdf.text(`${pageNum}`, pageWidth / 2, pageHeight - 10, { align: 'center' })
        pdf.text(title, margin, pageHeight - 10)
        pdf.setTextColor(0, 0, 0)
      }
      
      // Helper function to check if new page is needed
      const checkNewPage = (spaceNeeded = 20) => {
        if (yPosition + spaceNeeded > maxY) {
          addPageFooter(currentPage)
          pdf.addPage()
          currentPage++
          yPosition = margin
          return true
        }
        return false
      }
      
      // ============================================================
      // TITLE PAGE
      // ============================================================
      yPosition = pageHeight / 3
      
      pdf.setFontSize(32)
      pdf.setFont('times', 'bold')
      const titleLines = pdf.splitTextToSize(title, contentWidth - 20)
      titleLines.forEach(line => {
        pdf.text(line, pageWidth / 2, yPosition, { align: 'center' })
        yPosition += 14
      })
      
      yPosition += 25
      
      pdf.setFontSize(18)
      pdf.setFont('times', 'italic')
      pdf.text(`by ${author}`, pageWidth / 2, yPosition, { align: 'center' })
      
      // Publisher info at bottom
      yPosition = pageHeight - 30
      pdf.setFontSize(10)
      pdf.setFont('times', 'normal')
      pdf.text('Powered by Lekhika AI', pageWidth / 2, yPosition, { align: 'center' })
      pdf.text(new Date().toLocaleDateString(), pageWidth / 2, yPosition + 5, { align: 'center' })
      
      // ============================================================
      // TABLE OF CONTENTS
      // ============================================================
      pdf.addPage()
      currentPage++
      yPosition = margin + 15
      
      pdf.setFontSize(22)
      pdf.setFont('times', 'bold')
      pdf.text('Table of Contents', pageWidth / 2, yPosition, { align: 'center' })
      
      yPosition += 18
      pdf.setFontSize(12)
      pdf.setFont('times', 'normal')
      
      chapters.forEach((chapter, index) => {
        checkNewPage(10)
        const chapterTitle = chapter.title || `Chapter ${index + 1}`
        const chapterNum = chapter.metadata?.chapterNumber || (index + 1)
        
        pdf.text(`${chapterNum}. ${chapterTitle}`, margin + 5, yPosition)
        yPosition += 7
      })
      
      // ============================================================
      // CHAPTERS
      // ============================================================
      chapters.forEach((chapter, index) => {
        // Start each chapter on new page
        pdf.addPage()
        currentPage++
        yPosition = margin + 10
        
        const chapterTitle = chapter.title || `Chapter ${index + 1}`
        const chapterNum = chapter.metadata?.chapterNumber || (index + 1)
        const chapterContent = chapter.content || ''
        
        if (!chapterContent.trim()) {
          console.warn(`‚ö†Ô∏è Warning: Chapter ${chapterNum} has empty content`)
        }
        
        // Chapter number
        pdf.setFontSize(14)
        pdf.setFont('times', 'bold')
        pdf.setTextColor(80, 80, 80)
        pdf.text(`CHAPTER ${chapterNum}`, pageWidth / 2, yPosition, { align: 'center' })
        yPosition += 12
        
        // Chapter title
        pdf.setFontSize(20)
        pdf.setFont('times', 'bold')
        pdf.setTextColor(0, 0, 0)
        const chapterTitleLines = pdf.splitTextToSize(chapterTitle, contentWidth - 10)
        chapterTitleLines.forEach(line => {
          checkNewPage(10)
          pdf.text(line, pageWidth / 2, yPosition, { align: 'center' })
          yPosition += 9
        })
        
        yPosition += 18
        
        // Chapter content - proper paragraph handling with professional typography
        pdf.setFontSize(11.5)
        pdf.setFont('times', 'normal')
        pdf.setTextColor(30, 30, 30)
        
        // Split content into paragraphs
        const paragraphs = chapterContent.split('\n\n').filter(p => p.trim())
        
        paragraphs.forEach((paragraph, pIndex) => {
          checkNewPage(15)
          
          // Add extra space between paragraphs
          if (pIndex > 0) {
            yPosition += 5
          }
          
          const paragraphLines = pdf.splitTextToSize(paragraph.trim(), contentWidth)
          
          paragraphLines.forEach(line => {
            checkNewPage(6)
            pdf.text(line, margin, yPosition)
            yPosition += 5.5
          })
        })
        
        // Add footer to last page of chapter
        addPageFooter(currentPage)
      })
      
      // ============================================================
      // ABOUT THE AUTHOR (if available)
      // ============================================================
      const aboutAuthor = compiledContent.userInput?.about_author
      if (aboutAuthor && aboutAuthor.trim()) {
        pdf.addPage()
        currentPage++
        yPosition = margin + 10
        
        pdf.setFontSize(18)
        pdf.setFont('helvetica', 'bold')
        pdf.setTextColor(0, 0, 0)
        pdf.text('About the Author', pageWidth / 2, yPosition, { align: 'center' })
        
        yPosition += 15
        
        pdf.setFontSize(11)
        pdf.setFont('helvetica', 'normal')
        pdf.setTextColor(40, 40, 40)
        
        const aboutLines = pdf.splitTextToSize(aboutAuthor, contentWidth)
        aboutLines.forEach(line => {
          checkNewPage(6)
          pdf.text(line, margin, yPosition)
          yPosition += 5.5
        })
        
        addPageFooter(currentPage)
      }
      
      console.log(`‚úÖ PDF generated successfully: ${currentPage} pages`)
      
      // Return as blob for download
      const pdfBlob = pdf.output('blob')
      return URL.createObjectURL(pdfBlob)
      
    } catch (error) {
      console.error('‚ùå PDF generation failed:', error.message)
      console.error('Error details:', error)
      
      // DO NOT FALLBACK - REPORT THE ERROR
      throw new Error(`PDF generation failed: ${error.message}`)
    }
  }
  
  async generateHTML(compiledContent) {
    try {
      // Extract dynamic metadata - NO HARDCODED FALLBACKS
      const title = compiledContent.userInput?.book_title || 
                    compiledContent.userInput?.story_title || 
                    'Untitled'
      const author = compiledContent.userInput?.author_name || 'Unknown Author'
      
      // Get typography preferences
      const fontFamily = compiledContent.userInput?.font_family || 
                        compiledContent.userInput?.typography_combo?.split(',')[0] || 
                        'Georgia, serif'
      
      // Transform compiledContent.sections to flat chapter array
      let chapters = []
      const rawSections = compiledContent.sections || []
      
      rawSections.forEach((section, idx) => {
        if (Array.isArray(section.content)) {
          // Multi-chapter array - flatten it
          section.content.forEach(ch => {
            chapters.push({
              title: ch.title || `Chapter ${chapters.length + 1}`,
              content: ch.content || '',
              metadata: { chapterNumber: ch.chapter || chapters.length + 1 }
            })
          })
        } else if (typeof section.content === 'string') {
          // Extract chapter title from content string
          const content = section.content
          let chapterTitle = `Chapter ${idx + 1}`
          
          // Parse title from content (e.g., "Chapter 1: Title Name")
          const titleMatch = content.match(/^(?:Chapter|CHAPTER)\s*\d+:?\s*(.+?)(?:\n|$)/m)
          if (titleMatch && titleMatch[1]) {
            chapterTitle = titleMatch[1].trim().replace(/\*\*/g, '').trim()
          }
          
          chapters.push({
            title: chapterTitle,
            content: content,
            metadata: { chapterNumber: idx + 1 }
          })
        }
      })
      
      // Fallback: use raw content if no chapters extracted
      if (chapters.length === 0 && compiledContent.content) {
        chapters = [{
          title: title,
          content: compiledContent.content,
          metadata: { chapterNumber: 1 }
        }]
      }
      
      console.log(`üåê Generating HTML: "${title}" by ${author}`)
      console.log(`üåê Extracted ${chapters.length} chapters:`, chapters.map(c => c.title))
      
      let html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: ${fontFamily};
            line-height: 1.9;
            max-width: 900px;
            margin: 0 auto;
            padding: 40px 20px;
            background-color: #f9f9f9;
            color: #1a1a1a;
            font-size: 16px;
        }
        .container {
            background: white;
            padding: 60px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .title-page {
            text-align: center;
            padding: 80px 0;
            border-bottom: 2px solid #ecf0f1;
            margin-bottom: 60px;
        }
        h1 {
            color: #2c3e50;
            font-size: 3em;
            margin-bottom: 20px;
            font-weight: 700;
        }
        .author {
            font-style: italic;
            color: #7f8c8d;
            font-size: 1.5em;
            margin-bottom: 30px;
        }
        .metadata {
            color: #95a5a6;
            font-size: 0.9em;
        }
        .toc {
            margin: 60px 0;
            padding: 40px;
            background-color: #f8f9fa;
            border-radius: 8px;
        }
        .toc h2 {
            text-align: center;
            color: #2c3e50;
            font-size: 2em;
            margin-bottom: 30px;
            border: none;
        }
        .toc ul {
            list-style: none;
            padding: 0;
        }
        .toc li {
            padding: 10px 0;
            border-bottom: 1px solid #e0e0e0;
        }
        .toc li:last-child {
            border-bottom: none;
        }
        .toc a {
            text-decoration: none;
            color: #3498db;
            font-size: 1.1em;
            transition: color 0.3s;
        }
        .toc a:hover {
            color: #2980b9;
        }
        .chapter {
            margin: 80px 0;
            page-break-before: always;
        }
        .chapter-number {
            text-align: center;
            color: #95a5a6;
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
        }
        h2 {
            color: #34495e;
            text-align: center;
            font-size: 2.2em;
            margin-bottom: 40px;
            font-weight: 700;
        }
        .chapter-content {
            text-align: justify;
            line-height: 1.9;
        }
        .chapter-content p {
            margin-bottom: 20px;
            text-indent: 2em;
        }
        .chapter-content p:first-child {
            text-indent: 0;
        }
        .about-author {
            margin-top: 80px;
            padding-top: 40px;
            border-top: 2px solid #ecf0f1;
            page-break-before: always;
        }
        .about-author h2 {
            text-align: center;
            margin-bottom: 30px;
        }
        .about-author p {
            text-align: justify;
            line-height: 1.8;
        }
        @media print {
            body { 
                background: white; 
                max-width: 100%;
            }
            .container { 
                box-shadow: none;
                padding: 40px;
            }
            .chapter {
                page-break-before: always;
            }
        }
        @media (max-width: 768px) {
            .container {
                padding: 30px 20px;
            }
            h1 {
                font-size: 2em;
            }
            h2 {
                font-size: 1.5em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- TITLE PAGE -->
        <div class="title-page">
            <h1>${title}</h1>
            <div class="author">by ${author}</div>
            <div class="metadata">
                <p>Generated on: ${new Date().toLocaleDateString()}</p>
            </div>
        </div>
        
        <!-- TABLE OF CONTENTS -->
        <div class="toc">
            <h2>Table of Contents</h2>
            <ul>`
      
      // Build TOC
      chapters.forEach((chapter, index) => {
        const chapterTitle = chapter.title || `Chapter ${index + 1}`
        const chapterNum = chapter.metadata?.chapterNumber || (index + 1)
        const chapterId = `chapter-${chapterNum}`
        
        html += `
                <li><a href="#${chapterId}">${chapterNum}. ${chapterTitle}</a></li>`
      })
      
      html += `
            </ul>
        </div>
        
        <!-- CHAPTERS -->`
      
      // Build chapters
      chapters.forEach((chapter, index) => {
        const chapterTitle = chapter.title || `Chapter ${index + 1}`
        const chapterNum = chapter.metadata?.chapterNumber || (index + 1)
        const chapterId = `chapter-${chapterNum}`
        const chapterContent = chapter.content || ''
        
        if (!chapterContent.trim()) {
          console.warn(`‚ö†Ô∏è Warning: Chapter ${chapterNum} has empty content`)
        }
        
        html += `
        <div class="chapter" id="${chapterId}">
            <div class="chapter-number">CHAPTER ${chapterNum}</div>
            <h2>${chapterTitle}</h2>
            <div class="chapter-content">`
        
        // Split into paragraphs
        const paragraphs = chapterContent.split('\n\n').filter(p => p.trim())
        paragraphs.forEach(paragraph => {
          html += `
                <p>${paragraph.trim().replace(/\n/g, ' ')}</p>`
        })
        
        html += `
            </div>
        </div>`
      })
      
      // ABOUT THE AUTHOR (if available)
      const aboutAuthor = compiledContent.userInput?.about_author
      if (aboutAuthor && aboutAuthor.trim()) {
        html += `
        <div class="about-author">
            <h2>About the Author</h2>
            <p>${aboutAuthor}</p>
        </div>`
      }
      
      html += `
    </div>
</body>
</html>`
      
      console.log('‚úÖ HTML generated successfully')
      
      return html
      
    } catch (error) {
      console.error('‚ùå HTML generation failed:', error.message)
      console.error('Error details:', error)
      
      // DO NOT FALLBACK - REPORT THE ERROR
      throw new Error(`HTML generation failed: ${error.message}`)
    }
  }
  
  async generateEPUB(compiledContent) {
    // TEMPORARILY DISABLED: epub-gen is a Node.js library and cannot run in browser
    // This needs to be implemented as a server-side API endpoint
    throw new Error('EPUB generation is temporarily unavailable. The epub-gen library requires Node.js and cannot run in the browser. Please use PDF, DOCX, or Markdown formats instead.')
    
    /* ORIGINAL CODE COMMENTED OUT FOR FUTURE SERVER-SIDE IMPLEMENTATION
    try {
      // Extract dynamic metadata from user input - NO HARDCODED FALLBACKS
      const sections = compiledContent.sections || []
      const title = compiledContent.userInput?.book_title || 
                    compiledContent.userInput?.story_title || 
                    'Untitled'
      const author = compiledContent.userInput?.author_name || 'Unknown Author'
      
      console.log(`üìö Generating EPUB: "${title}" by ${author}`)
      console.log(`üìö Total sections: ${sections.length}`)
      
      // Build chapters from actual content sections - DYNAMIC, NOT HARDCODED
      const chapters = sections.map((section, index) => {
        const chapterTitle = section.title || section.metadata?.title || `Chapter ${index + 1}`
        const chapterContent = section.content || ''
        
        if (!chapterContent.trim()) {
          console.warn(`‚ö†Ô∏è Warning: Chapter ${index + 1} has empty content`)
        }
        
        // Format content as proper HTML paragraphs
        const formattedContent = chapterContent
          .split('\n\n')
          .filter(para => para.trim())
          .map(para => `<p>${para.trim().replace(/\n/g, ' ')}</p>`)
          .join('\n')
        
        return {
          title: chapterTitle,
          data: formattedContent || '<p>Chapter content unavailable</p>'
        }
      })
      
      // Build EPUB metadata - ALL DYNAMIC FROM USER INPUT
      const epubOptions = {
        title: title,
        author: author,
        publisher: compiledContent.userInput?.publisher || 'Lekhika AI',
        description: compiledContent.userInput?.description || 
                    compiledContent.userInput?.story_premise || 
                    `${title} by ${author}`,
        cover: compiledContent.userInput?.cover_image || undefined,
        isbn: compiledContent.userInput?.isbn || undefined,
        lang: compiledContent.userInput?.language || 'en',
        tocTitle: 'Table of Contents',
        appendChapterTitles: true,
        customOpfTemplatePath: undefined,
        customNcxTocTemplatePath: undefined,
        customHtmlTocTemplatePath: undefined,
        content: chapters,
        verbose: false
      }
      
      console.log('üìö EPUB Options:', {
        title: epubOptions.title,
        author: epubOptions.author,
        chapters: chapters.length,
        publisher: epubOptions.publisher
      })
      
      // Generate EPUB file as ArrayBuffer (browser-compatible)
      const epub = new EPub(epubOptions)
      const epubBuffer = await epub.genEpub()
      
      console.log('‚úÖ EPUB generated successfully, size:', epubBuffer.byteLength, 'bytes')
      
      // Convert ArrayBuffer to Blob for browser download
      const blob = new Blob([epubBuffer], { 
        type: 'application/epub+zip' 
      })
      
      // Create object URL for download
      const downloadUrl = URL.createObjectURL(blob)
      
      console.log('‚úÖ EPUB download URL created')
      
      return downloadUrl
      
    } catch (error) {
      console.error('‚ùå EPUB generation failed:', error.message)
      console.error('Error details:', error)
      
      // DO NOT FALLBACK TO FAKE FORMATS - REPORT THE ERROR
      throw new Error(`EPUB generation failed: ${error.message}`)
    }
    */
  }

  async generateMarkdown(compiledContent) {
    try {
      // Extract dynamic metadata - NO HARDCODED FALLBACKS
      const title = compiledContent.userInput?.book_title || 
                    compiledContent.userInput?.story_title || 
                    'Untitled'
      const author = compiledContent.userInput?.author_name || 'Unknown Author'
      
      // Transform compiledContent.sections to flat chapter array
      let chapters = []
      const rawSections = compiledContent.sections || []
      
      rawSections.forEach((section, idx) => {
        if (Array.isArray(section.content)) {
          // Multi-chapter array - flatten it
          section.content.forEach(ch => {
            chapters.push({
              title: ch.title || `Chapter ${chapters.length + 1}`,
              content: ch.content || '',
              metadata: { chapterNumber: ch.chapter || chapters.length + 1 }
            })
          })
        } else if (typeof section.content === 'string') {
          // Extract chapter title from content string
          const content = section.content
          let chapterTitle = `Chapter ${idx + 1}`
          
          // Parse title from content (e.g., "Chapter 1: Title Name")
          const titleMatch = content.match(/^(?:Chapter|CHAPTER)\s*\d+:?\s*(.+?)(?:\n|$)/m)
          if (titleMatch && titleMatch[1]) {
            chapterTitle = titleMatch[1].trim().replace(/\*\*/g, '').trim()
          }
          
          chapters.push({
            title: chapterTitle,
            content: content,
            metadata: { chapterNumber: idx + 1 }
          })
        }
      })
      
      // Fallback: use raw content if no chapters extracted
      if (chapters.length === 0 && compiledContent.content) {
        chapters = [{
          title: title,
          content: compiledContent.content,
          metadata: { chapterNumber: 1 }
        }]
      }
      
      console.log(`üìù Generating Markdown: "${title}" by ${author}`)
      console.log(`üìù Extracted ${chapters.length} chapters:`, chapters.map(c => c.title))
      
      let markdown = `# ${title}\n\n`
      markdown += `*by ${author}*\n\n`
      markdown += `---\n\n`
      markdown += `**Generated on:** ${new Date().toLocaleDateString()}\n\n`
      
      // Add total words if available
      if (compiledContent.totalWords) {
        markdown += `**Total Words:** ${compiledContent.totalWords}\n\n`
      }
      
      markdown += `---\n\n`
      
      // TABLE OF CONTENTS
      markdown += `## Table of Contents\n\n`
      
      chapters.forEach((chapter, index) => {
        const chapterTitle = chapter.title || `Chapter ${index + 1}`
        const chapterNum = chapter.metadata?.chapterNumber || (index + 1)
        const anchor = chapterTitle.toLowerCase().replace(/[^a-z0-9]+/g, '-')
        
        markdown += `${chapterNum}. [${chapterTitle}](#${anchor})\n`
      })
      
      markdown += `\n---\n\n`
      
      // CHAPTERS
      chapters.forEach((chapter, index) => {
        const chapterTitle = chapter.title || `Chapter ${index + 1}`
        const chapterNum = chapter.metadata?.chapterNumber || (index + 1)
        const chapterContent = chapter.content || ''
        
        if (!chapterContent.trim()) {
          console.warn(`‚ö†Ô∏è Warning: Chapter ${chapterNum} has empty content`)
        }
        
        markdown += `## Chapter ${chapterNum}: ${chapterTitle}\n\n`
        markdown += `${chapterContent.trim()}\n\n`
        markdown += `---\n\n`
      })
      
      // ABOUT THE AUTHOR (if available)
      const aboutAuthor = compiledContent.userInput?.about_author
      if (aboutAuthor && aboutAuthor.trim()) {
        markdown += `## About the Author\n\n`
        markdown += `${aboutAuthor}\n\n`
      }
      
      console.log('‚úÖ Markdown generated successfully')
      
      return markdown
      
    } catch (error) {
      console.error('‚ùå Markdown generation failed:', error.message)
      console.error('Error details:', error)
      
      // DO NOT FALLBACK - REPORT THE ERROR
      throw new Error(`Markdown generation failed: ${error.message}`)
    }
  }
}

export default new ExportService()