import React, { useState, useEffect } from 'react'
import { X, Save, Settings, FileText, Brain, Image, CheckCircle, GitBranch, Plus, Trash2, Zap, AlertTriangle, RefreshCw, Eye } from 'lucide-react'
import toast from 'react-hot-toast'
import { getAllAvailableVariables } from '../../data/variables.js'
import { supabase } from '../../lib/supabase'
import { aiModelService } from '../../services/aiModelService'
import { aiModelDiscoveryService } from '../../services/aiModelDiscoveryService'
import { NODE_PALETTES, NODE_ROLE_CONFIG } from '../../data/nodePalettes'

// Get node configuration from nodePalettes.js system
const getNodeConfiguration = (nodeType, nodeRole) => {
  // If nodeRole is provided, get specific node configuration
  if (nodeRole && NODE_PALETTES[nodeType] && NODE_PALETTES[nodeType][nodeRole]) {
    return NODE_PALETTES[nodeType][nodeRole].configuration
  }
  
  // Otherwise return default configuration for node type
  const defaultConfigs = {
    input: {
      inputFields: [],
      outputFormat: 'structured_json',
      processingInstructions: 'Process user inputs and format into structured JSON for next nodes'
    },
    process: {
      systemPrompt: 'You are a professional content processor.',
      userPrompt: 'Process the provided content according to your specialized role.',
      maxTokens: 4000,
      temperature: 0.7,
      outputFormat: 'processed_content'
    },
    condition: {
      conditions: [],
      defaultRoute: 'continue',
      outputFormat: 'routing_decision'
    },
    preview: {
      previewSections: ['content'],
      feedbackFields: [],
      outputFormat: 'preview_feedback'
    },
    output: {
      outputFormat: 'html',
      exportFormats: ['html', 'pdf', 'text'],
      generateCover: false,
      includeTOC: true
    }
  }
  
  return defaultConfigs[nodeType] || defaultConfigs.process
}

// Get processing instructions from nodePalettes.js
const getNodeInstructions = (nodeType, nodeRole) => {
  // If nodeRole is provided, get specific node configuration
  if (nodeRole && NODE_PALETTES[nodeType] && NODE_PALETTES[nodeType][nodeRole]) {
    const nodeConfig = NODE_PALETTES[nodeType][nodeRole].configuration
    return nodeConfig.processingInstructions || nodeConfig.systemPrompt || `Process content according to ${nodeType} node requirements`
  }
  
  // Fallback to default configuration
  const config = getNodeConfiguration(nodeType, nodeRole)
  return config.processingInstructions || config.systemPrompt || `Process content according to ${nodeType} node requirements`
}

// Expert system prompts for optimal AI model performance
const getDefaultSystemPrompt = (nodeType) => {
  const systemPrompts = {
    input: "You are an elite Input Validation and Enhancement Specialist with deep expertise in content strategy, publishing standards, and workflow optimization. Your core mission: intelligently validate, enhance, and structure user inputs for optimal downstream processing. CAPABILITIES: Smart consistency validation, intelligent gap-filling, format standardization, conflict resolution, and professional data structuring. Apply surgical precision to ensure 100% accuracy while enhancing incomplete inputs with contextually appropriate suggestions. Flag inconsistencies immediately and resolve conflicts using industry best practices.",
    
    process: "You are an elite content creation specialist with world-class expertise across all literary genres and publishing formats. Your mission is to produce exceptional, publication-ready content that exceeds industry standards. Maintain perfect consistency in tone and style, apply advanced storytelling techniques, ensure factual accuracy, and optimize for maximum reader engagement. Every output must meet professional publishing grade quality.",
    
    condition: "You are a sophisticated decision engine with advanced analytical capabilities. Apply rigorous logical evaluation to all conditions, consider full context and workflow objectives, and implement intelligent routing with precision. Ensure seamless continuation regardless of path taken, maintain data integrity, and apply professional standards to all decision pathways and fallback options.",
    
    output: "You are a master publishing specialist responsible for delivering world-class final products. Apply advanced formatting and presentation optimization, conduct comprehensive quality assurance, ensure perfect alignment with specifications, and optimize for target format requirements. Every output must be publication-ready with zero errors and professional presentation."
  }
  
  return systemPrompts[nodeType] || systemPrompts.process
}

// Expert user prompt templates with dynamic variables
const getDefaultUserPrompt = (nodeType) => {
  const userPrompts = {
    input: `INTELLIGENT INPUT PROCESSING & VALIDATION

ANALYZE these user inputs with expert precision:
{user_input_data}

EXECUTE these validation and enhancement tasks:

1. SMART VALIDATION:
   - Check logical consistency (genre vs style vs audience)
   - Validate realistic word count vs chapter count ratios
   - Flag conflicting requirements or impossible combinations
   - Ensure all critical fields have meaningful values

2. INTELLIGENT ENHANCEMENT:
   - Fill missing optional details based on genre/type context
   - Suggest appropriate defaults for unspecified preferences
   - Enhance vague inputs with specific, actionable details
   - Add industry-standard metadata where beneficial

3. CONFLICT RESOLUTION:
   - Resolve contradictory inputs using best practices
   - Prioritize user intent over conflicting specifications
   - Provide clear reasoning for resolution decisions

4. PROFESSIONAL STRUCTURING:
   - Format all data consistently for downstream processing
   - Create comprehensive variable mapping
   - Generate processing metadata and quality flags
   - Prepare optimized data package for next workflow node

OUTPUT FORMAT: Structured JSON with validated inputs, enhancements, flags, and processing instructions.`,

    process: `Create exceptional content based on these specifications:

Project Context: {previous_output}
Content Requirements: {content_type}, {word_count}
Style Guidelines: {tone}, {writing_style}, {accent}
Target Audience: {target_audience}
Special Instructions: {custom_instructions}

Produce publication-ready content that exceeds professional standards and perfectly aligns with user specifications.`,

    condition: `Evaluate the following condition with expert analysis:

Input Data: {input_data}
Condition Parameters: {condition_field} {condition_operator} {condition_value}
Workflow Context: {workflow_context}

Apply rigorous logical evaluation and execute the appropriate action path based on your assessment.`,

    output: `Finalize the complete project deliverable:

Compiled Content: {workflow_output}
Format Requirements: {output_format}
Quality Standards: Publication-ready, professional presentation
Additional Features: {generate_cover}, {include_images}
User Specifications: {custom_requirements}

Deliver a world-class final product that exceeds all expectations and meets professional publishing standards.`
  }
  
  return userPrompts[nodeType] || userPrompts.process
}

const FlowNodeModal = ({ isOpen, onClose, node, nodes, edges, onSave, onDelete, inputOptions }) => {
  // Helper function to resolve options from optionsSource
  const getFieldOptions = (field) => {
    if (field.optionsSource && inputOptions?.[field.optionsSource]) {
      return inputOptions[field.optionsSource]
    }
    return field.options || []
  }
  const [config, setConfig] = useState({
    label: '',
    description: '',
    type: 'input',
    
    // Input Instructions
    inputInstructions: '',
    
    // Input Variables
    inputVariables: [],
    
    // AI Integration
    aiEnabled: true, // Default to enabled
    selectedModels: [],
    temperature: 0.7,
    maxTokens: 2000,
    systemPrompt: '',
    userPrompt: '',
    
    // Node-specific configs
    inputFields: [],
    conditions: [],
    outputFormat: 'text',
    generateCover: false,
    
    
    // Flow awareness
    connectedNodes: [],
    
    ...node?.data
  })

  const [activeTab, setActiveTab] = useState('basic')
  const [availableProviders, setAvailableProviders] = useState([])
  const [availableModels, setAvailableModels] = useState({})
  const [loading, setLoading] = useState(false)
  const [selectedProvider, setSelectedProvider] = useState('')
  const [syncing, setSyncing] = useState(false)
  
  // Test input state - using the SAME values that were hardcoded
  const [testInputEnabled, setTestInputEnabled] = useState(false)
  const [inputValues, setInputValues] = useState({})
  const [testInputValues, setTestInputValues] = useState({
    // Basic Book Fields - Standardized naming
    book_title: "The Ultimate AI Transformation Guide",
    author_name: "Dr. Alex Johnson",
    author_bio: "Award-winning AI researcher and bestselling author with 20+ years of experience in digital transformation",
    word_count: "25000-35000",
    chapter_count: "8-10",
    tone: "professional",
    accent: "american",
    target_audience: "professionals",
    industry_focus: "technology",
    "Book Description": "A comprehensive guide to transforming businesses through artificial intelligence, covering implementation strategies, case studies, and practical applications for modern enterprises.",
    
    // Additional Framework Fields
    include_case_studies: true,
    include_templates: true,
    include_worksheets: true,
    custom_instructions: "Focus on practical implementation and real-world applications",
    publishing_format: "ebook",
    content_depth: "comprehensive",
    research_level: "moderate",
    practical_applications: true,
    business_model: "b2b",
    output_formats: ["pdf", "docx", "epub"],
    book_size: "A4",
    custom_size: "",
    typography_style: "professional",
    cover_design: "professional",
    
    // Self-Help Guide Specific Fields
    guide_title: "The Complete Self-Help Transformation Guide",
    development_area: "confidence",
    include_exercises: true,
    include_worksheets: true,
    include_meditations: false,
    
    // Framework-Specific Fields (Business Strategy Guide)
    company_size: "medium_business",
    strategic_goal: "growth",
    business_niche: "b2b",
    market_position: "challenger",
    competitive_landscape: "Highly competitive market with established players and emerging disruptors",
    revenue_model: "subscription",
    growth_stage: "growth_stage",
    
    // Framework-Specific Fields (Technical Manual)
    technical_level: "intermediate",
    programming_language: "python",
    implementation_type: "step_by_step",
    platform_requirements: "cross_platform",
    prerequisites: "Basic programming knowledge, familiarity with development tools",
    tools_frameworks: "Python 3.8+, VS Code, Git, Docker",
    certification_aligned: true,
    
    // Advanced Features
    include_case_studies: true,
    include_templates: true,
    include_worksheets: true,
    include_code_examples: true,
    include_diagrams: true,
    include_troubleshooting: true,
    
    // Other Fields
    industryFocus: "Enterprise",
    industry_focus: "technology",
    brandingStyle: "Modern",
    branding_style: "Modern",
    chapterCount: 1,
    chapter_count: 1,
    numberOfChapters: 1,
    includeImages: true,
    include_images: true,
    voiceCloningEnabled: true,
    voice_cloning_enabled: true,
    factCheckingEnabled: true,
    fact_checking_enabled: true,
    interactiveContent: true,
    interactive_content: true,
    customInstructions: "Focus on real-world case studies and actionable insights",
    custom_instructions: "Focus on real-world case studies and actionable insights"
  })

  // Load AI providers dynamically
  useEffect(() => {
    if (config.aiEnabled) {
      loadAIProviders()
    }
  }, [config.aiEnabled])

  // Load AI providers on modal open since AI is enabled by default
  useEffect(() => {
    if (isOpen && config.aiEnabled) {
      loadAIProviders()
    }
  }, [isOpen])

  // Generate test scenarios based on flow type
  const generateTestScenarios = (inputFields, flowType = 'generic') => {
    const scenarios = {
      // Business eBook scenarios
      businessEbook: [
        {
          name: 'AI Startup Guide',
          data: {
            book_title: 'The AI Startup Playbook',
            business_niche: 'entrepreneurship',
            target_audience: 'entrepreneurs',
            word_count: 15000,
            tone: 'professional',
            include_case_studies: true,
            include_templates: true
          }
        },
        {
          name: 'Leadership Excellence',
          data: {
            book_title: 'Leading in the Digital Age',
            business_niche: 'leadership',
            target_audience: 'executives',
            word_count: 20000,
            tone: 'authoritative',
            include_case_studies: true,
            include_templates: false
          }
        },
        {
          name: 'Marketing Mastery',
          data: {
            book_title: 'Growth Marketing Strategies',
            business_niche: 'marketing',
            target_audience: 'small_business',
            word_count: 18000,
            tone: 'conversational',
            include_case_studies: false,
            include_templates: true
          }
        },
        {
          name: 'Financial Planning',
          data: {
            book_title: 'Small Business Finance Guide',
            business_niche: 'finance',
            target_audience: 'entrepreneurs',
            word_count: 12000,
            tone: 'professional',
            include_case_studies: true,
            include_templates: true
          }
        },
        {
          name: 'Operations Optimization',
          data: {
            book_title: 'Streamlining Business Operations',
            business_niche: 'operations',
            target_audience: 'managers',
            word_count: 16000,
            tone: 'professional',
            include_case_studies: false,
            include_templates: true
          }
        }
      ],
      
      // Report Creator scenarios
      reportCreator: [
        {
          name: 'Q4 Performance Report',
          data: {
            report_title: 'Q4 2024 Performance Analysis',
            report_type: 'performance_review',
            target_audience: 'executives',
            word_count: 3000,
            data_sources: 'Sales CRM, Google Analytics, Customer Feedback',
            key_metrics: 'Revenue, Conversion Rate, Customer Satisfaction'
          }
        },
        {
          name: 'Market Research Report',
          data: {
            report_title: 'AI Tools Market Analysis 2024',
            report_type: 'market_research',
            target_audience: 'stakeholders',
            word_count: 4000,
            data_sources: 'Industry Reports, Competitor Analysis, Surveys',
            key_metrics: 'Market Size, Growth Rate, Competitive Landscape'
          }
        },
        {
          name: 'Financial Summary',
          data: {
            report_title: 'Monthly Financial Dashboard',
            report_type: 'financial_summary',
            target_audience: 'board_members',
            word_count: 2500,
            data_sources: 'QuickBooks, Bank Statements, Expense Reports',
            key_metrics: 'Revenue, Expenses, Profit Margin, Cash Flow'
          }
        },
        {
          name: 'Project Status Update',
          data: {
            report_title: 'Website Redesign Project Status',
            report_type: 'project_status',
            target_audience: 'team_members',
            word_count: 2000,
            data_sources: 'Project Management Tool, Developer Reports',
            key_metrics: 'Completion Rate, Budget Utilization, Timeline'
          }
        },
        {
          name: 'Compliance Report',
          data: {
            report_title: 'GDPR Compliance Audit Report',
            report_type: 'compliance_report',
            target_audience: 'executives',
            word_count: 3500,
            data_sources: 'Legal Documentation, System Logs, Policy Reviews',
            key_metrics: 'Compliance Score, Risk Assessment, Recommendations'
          }
        }
      ],

      // Guide Creator scenarios
      guideCreator: [
        {
          name: 'Complete Beginner Guide',
          data: {
            guide_title: 'Complete Beginner Guide to Digital Marketing',
            development_area: 'digital_marketing',
            target_audience: 'beginners',
            word_count: 8000,
            key_items: 'SEO basics, Social media, Email marketing, Analytics',
            include_visual_elements: true,
            include_advanced_features: false,
            include_interactive_elements: false
          }
        },
        {
          name: 'Advanced Tutorial',
          data: {
            guide_title: 'Advanced React Development Techniques',
            development_area: 'web_development',
            target_audience: 'intermediate',
            word_count: 12000,
            key_items: 'Hooks, Context API, Performance optimization, Testing',
            include_visual_elements: true,
            include_advanced_features: true,
            include_interactive_elements: true
          }
        },
        {
          name: 'Quick Reference',
          data: {
            guide_title: 'Python Data Analysis Quick Reference',
            development_area: 'data_science',
            target_audience: 'intermediate',
            word_count: 5000,
            key_items: 'Pandas, NumPy, Matplotlib, Common operations',
            include_visual_elements: true,
            include_advanced_features: false,
            include_interactive_elements: false
          }
        },
        {
          name: 'Professional Manual',
          data: {
            guide_title: 'Project Management Best Practices Manual',
            development_area: 'project_management',
            target_audience: 'professionals',
            word_count: 15000,
            key_items: 'Planning, Execution, Monitoring, Risk management',
            include_visual_elements: true,
            include_advanced_features: true,
            include_interactive_elements: true
          }
        },
        {
          name: 'Step-by-Step Tutorial',
          data: {
            guide_title: 'Building Your First Mobile App',
            development_area: 'mobile_development',
            target_audience: 'beginners',
            word_count: 10000,
            key_items: 'Setup, Design, Development, Testing, Deployment',
            include_visual_elements: true,
            include_advanced_features: false,
            include_interactive_elements: true
          }
        }
      ],

      // Comprehensive Book scenarios
      comprehensiveBook: [
        {
          name: 'AI Transformation Guide',
          data: {
            bookTitle: 'The Ultimate AI Transformation Guide',
            authorName: 'Anwesh Rath',
            topic: 'technology',
            wordCount: '5000-10000',
            tone: 'professional',
            accent: 'american',
            targetAudience: 'Professional',
            chapterCount: 2,
            includeImages: true
          }
        },
        {
          name: 'Digital Marketing Mastery',
          data: {
            bookTitle: 'Digital Marketing Mastery: From Zero to Hero',
            authorName: 'Sarah Johnson',
            topic: 'marketing',
            wordCount: '25000-35000',
            tone: 'conversational',
            accent: 'british',
            targetAudience: 'Intermediate',
            chapterCount: 8,
            includeImages: true
          }
        },
        {
          name: 'Startup Success Blueprint',
          data: {
            bookTitle: 'The Startup Success Blueprint',
            authorName: 'Mike Chen',
            topic: 'business',
            wordCount: '35000-50000',
            tone: 'authoritative',
            accent: 'american',
            targetAudience: 'Expert',
            chapterCount: 12,
            includeImages: false
          }
        },
        {
          name: 'Personal Finance Guide',
          data: {
            bookTitle: 'Smart Money: Personal Finance for Millennials',
            authorName: 'Emma Davis',
            topic: 'finance',
            wordCount: '15000-25000',
            tone: 'conversational',
            accent: 'american',
            targetAudience: 'Beginner',
            chapterCount: 6,
            includeImages: true
          }
        },
        {
          name: 'Leadership Excellence',
          data: {
            bookTitle: 'Leadership Excellence in the Modern Era',
            authorName: 'Dr. Robert Kim',
            topic: 'leadership',
            wordCount: '40000-60000',
            tone: 'professional',
            accent: 'american',
            targetAudience: 'Advanced',
            chapterCount: 10,
            includeImages: true
          }
        }
      ],

      // Generic scenarios for unknown flow types
      generic: [
        {
          name: 'Professional Scenario',
          data: {}
        },
        {
          name: 'Beginner-Friendly',
          data: {}
        },
        {
          name: 'Advanced Expert',
          data: {}
        },
        {
          name: 'Quick & Simple',
          data: {}
        },
        {
          name: 'Comprehensive Guide',
          data: {}
        }
      ]
    }

    // Determine flow type from input fields
    let detectedType = 'generic'
    if (inputFields) {
      const fieldNames = inputFields.map(f => f.name?.toLowerCase() || '')
      const fieldVars = inputFields.map(f => f.variable?.toLowerCase() || '')
      const allFields = [...fieldNames, ...fieldVars].join(' ')

      if (allFields.includes('business') || allFields.includes('niche') || allFields.includes('entrepreneur')) {
        detectedType = 'businessEbook'
      } else if (allFields.includes('report') || allFields.includes('analysis') || allFields.includes('metrics')) {
        detectedType = 'reportCreator'
      } else if (allFields.includes('guide') || allFields.includes('tutorial') || allFields.includes('development_area')) {
        detectedType = 'guideCreator'
      } else if (allFields.includes('booktitle') || allFields.includes('authorname') || allFields.includes('chaptercount') || allFields.includes('targetaudience')) {
        detectedType = 'comprehensiveBook'
      }
    }

    // Get scenarios for detected type
    const typeScenarios = scenarios[detectedType] || scenarios.generic
    
    // Fill in ALL fields with realistic defaults - NO BLANK FIELDS!
    return typeScenarios.map(scenario => {
      const filledData = { ...scenario.data }
      
      inputFields?.forEach(field => {
        const fieldKey = field.name || field.variable
        const fieldName = field.name?.toLowerCase() || field.variable?.toLowerCase() || ''
        
        // If field is not already filled by scenario, fill it with realistic data
        if (!filledData[fieldKey]) {
          if (field.type === 'select' && getFieldOptions(field)?.length > 0) {
            // Pick a realistic option based on field name
            let selectedOption = ''
            const options = getFieldOptions(field)
            if (fieldName.includes('tone')) {
              selectedOption = options.includes('professional') ? 'professional' : 
                             options.includes('conversational') ? 'conversational' : options[0]
            } else if (fieldName.includes('accent')) {
              selectedOption = options.includes('american') ? 'american' : 
                             options.includes('british') ? 'british' : options[0]
            } else if (fieldName.includes('audience') || fieldName.includes('level')) {
              selectedOption = options.includes('beginner') ? 'beginner' : 
                             options.includes('professional') ? 'professional' : options[0]
            } else if (fieldName.includes('niche') || fieldName.includes('topic')) {
              selectedOption = options.includes('technology') ? 'technology' : 
                             options.includes('business') ? 'business' : options[0]
            } else {
              selectedOption = options.find(opt => 
                typeof opt === 'string' ? opt !== '' : opt.value !== ''
              ) || options[0]
            }
            if (field.multiple) {
              // For multiple selection, pick 2-3 realistic options
              let selectedOptions = []
              if (fieldName.includes('output_formats')) {
                selectedOptions = ['pdf', 'docx'].filter(opt => options.includes(opt))
                if (selectedOptions.length === 0) selectedOptions = options.slice(0, 2)
              } else {
                selectedOptions = options.slice(0, 2)
              }
              filledData[fieldKey] = selectedOptions
            } else {
              filledData[fieldKey] = typeof selectedOption === 'string' ? selectedOption : selectedOption?.value || ''
            }
          } else if (field.type === 'number') {
            if (fieldName.includes('word') || fieldName.includes('count')) {
              filledData[fieldKey] = 5000
            } else if (fieldName.includes('chapter')) {
              filledData[fieldKey] = 8
            } else if (fieldName.includes('page')) {
              filledData[fieldKey] = 50
            } else {
              filledData[fieldKey] = field.min || 1000
            }
          } else if (field.type === 'checkbox' || field.type === 'boolean') {
            // Smart defaults based on field name
            if (fieldName.includes('include') || fieldName.includes('enable') || fieldName.includes('active')) {
              filledData[fieldKey] = true
            } else {
              filledData[fieldKey] = false
            }
          } else if (field.type === 'textarea') {
            // Realistic textarea content based on field name
            if (fieldName.includes('description') || fieldName.includes('bio')) {
              filledData[fieldKey] = 'A comprehensive guide designed to help professionals master the fundamentals and advance their expertise in this field.'
            } else if (fieldName.includes('instruction') || fieldName.includes('requirement')) {
              filledData[fieldKey] = 'Please provide detailed specifications and requirements for optimal content generation.'
            } else if (fieldName.includes('strategy') || fieldName.includes('approach')) {
              filledData[fieldKey] = 'Focus on practical, actionable strategies that deliver measurable results and long-term value.'
            } else {
              filledData[fieldKey] = 'Detailed information and specifications for this content area.'
            }
          } else {
            // Text fields - realistic content based on field name
            if (fieldName.includes('title') && !fieldName.includes('sub')) {
              filledData[fieldKey] = 'Professional Guide to Success'
            } else if (fieldName.includes('author') || fieldName.includes('name')) {
              filledData[fieldKey] = 'Expert Author'
            } else if (fieldName.includes('company') || fieldName.includes('organization')) {
              filledData[fieldKey] = 'Professional Solutions Inc.'
            } else if (fieldName.includes('email')) {
              filledData[fieldKey] = 'contact@example.com'
            } else if (fieldName.includes('phone')) {
              filledData[fieldKey] = '+1 (555) 123-4567'
            } else if (fieldName.includes('url') || fieldName.includes('website')) {
              filledData[fieldKey] = 'https://www.example.com'
            } else if (fieldName.includes('industry') || fieldName.includes('sector')) {
              filledData[fieldKey] = 'Technology'
            } else if (fieldName.includes('location') || fieldName.includes('address')) {
              filledData[fieldKey] = 'New York, NY'
            } else {
              filledData[fieldKey] = field.placeholder || `Sample ${fieldKey.replace(/_/g, ' ')}`
            }
          }
        }
      })
      
      return {
        ...scenario,
        data: filledData
      }
    })
  }

  // Generate default test input values based on input fields
  const generateDefaultTestInput = (inputFields) => {
    const defaults = {}
    
    // Generate values for ALL input fields dynamically
    inputFields?.forEach(field => {
      const fieldName = field.variable || field.name
      
      if (field.type === 'select' && getFieldOptions(field)?.length > 0) {
        if (field.multiple) {
          // For multiple selection, default to first 2-3 options
          const options = getFieldOptions(field)
          const validOptions = options.filter(opt => 
            typeof opt === 'string' ? opt !== '' : opt.value !== ''
          )
          defaults[fieldName] = validOptions.slice(0, 2).map(opt => 
            typeof opt === 'string' ? opt : opt.value
          )
        } else {
          // Use first non-empty option as default
          const options = getFieldOptions(field)
          const firstOption = options.find(opt => 
            typeof opt === 'string' ? opt !== '' : opt.value !== ''
          )
          if (firstOption) {
            defaults[fieldName] = typeof firstOption === 'string' ? firstOption : firstOption.value
          } else {
            defaults[fieldName] = options[0]
          }
        }
      } else if (field.type === 'checkbox') {
        defaults[fieldName] = field.required || false
      } else if (field.type === 'textarea') {
        defaults[fieldName] = field.placeholder || `Enter ${field.name || fieldName}`
      } else if (field.type === 'text') {
        defaults[fieldName] = field.placeholder || `Enter ${field.name || fieldName}`
      } else if (field.type === 'number') {
        defaults[fieldName] = field.min || 1000
      } else {
        // Default fallback for any other field types
        defaults[fieldName] = field.placeholder || `Enter ${field.name || fieldName}`
      }
    })
    
    return defaults
  }

  // Sync Basic Input with Test Input (for consistency)
  const syncBasicInputWithTestInput = () => {
    // Copy all test input values to basic input
    setInputValues({ ...testInputValues })
    toast.success('Test Input synced to Basic Input')
  }

  // Validate input field coverage
  const validateInputCoverage = () => {
    const missingFields = []
    const inputFields = config.inputFields || []
    
    inputFields.forEach(field => {
      const fieldName = field.variable || field.name
      const hasBasicValue = inputValues[fieldName] !== undefined && inputValues[fieldName] !== ''
      const hasTestValue = testInputValues[fieldName] !== undefined && testInputValues[fieldName] !== ''
      
      if (field.required && !hasBasicValue && !hasTestValue) {
        missingFields.push(fieldName)
      }
    })
    
    return {
      isValid: missingFields.length === 0,
      missingFields,
      coverage: {
        basic: inputFields.filter(field => {
          const fieldName = field.variable || field.name
          return inputValues[fieldName] !== undefined && inputValues[fieldName] !== ''
        }).length,
        test: inputFields.filter(field => {
          const fieldName = field.variable || field.name
          return testInputValues[fieldName] !== undefined && testInputValues[fieldName] !== ''
        }).length,
        total: inputFields.length
      }
    }
  }

  // Helper function to get all available variables from single source
  const getAllAvailableVariablesLocal = () => {
    return getAllAvailableVariables()
  }

  // Helper function to get all available variables from connected input nodes
  const getAvailableVariablesFromInputNodes = () => {
    const inputNodes = nodes.filter(node => node.type === 'input')
    const allVariables = []
    
    // Convert variable name to proper display name if name is missing
    const getDisplayName = (variable, name) => {
      if (name) return name
      // Convert camelCase/snake_case to proper display name
      return variable
        .replace(/([A-Z])/g, ' $1') // Add space before capital letters
        .replace(/_/g, ' ') // Replace underscores with spaces
        .replace(/^./, str => str.toUpperCase()) // Capitalize first letter
        .trim()
    }
    
    inputNodes.forEach(node => {
      if (node.data?.inputFields) {
        node.data.inputFields.forEach(field => {
          allVariables.push({
            variable: field.variable,
            name: getDisplayName(field.variable, field.name),
            type: field.type,
            sourceNode: node.data.label || node.id
          })
        })
      }
    })
    
    return allVariables
  }
  }

  // Helper function to add a variable to input fields
  const addVariableToInput = (variable) => {
    const newField = {
      id: Date.now(), // Simple ID generation
      name: variable.name,
      type: variable.type,
      required: variable.required,
      variable: variable.variable,
      placeholder: variable.placeholder,
      options: variable.options
    }
    
    // Add to inputFields
    const updatedInputFields = [...config.inputFields, newField]
    setConfig(prev => ({ ...prev, inputFields: updatedInputFields }))
    
    // Add to testInputValues with default value
    const defaultValue = variable.type === 'select' && variable.options.length > 0 
      ? variable.options[0] 
      : variable.type === 'boolean' 
        ? false 
        : variable.type === 'number' 
          ? 0 
          : ''
    
    setTestInputValues(prev => ({
      ...prev,
      [variable.variable]: defaultValue
    }))
    
    // Add to inputValues with default value
    setInputValues(prev => ({
      ...prev,
      [variable.variable]: defaultValue
    }))
  }

  // Helper function to insert variable into prompt template
  const insertVariableIntoPrompt = (variable, promptType) => {
    const variableToken = `{${variable.variable}}`
    const currentPrompt = promptType === 'system' ? config.systemPrompt : config.userPrompt
    const newPrompt = currentPrompt + (currentPrompt.endsWith('\n') ? '' : '\n') + variableToken
    
    if (promptType === 'system') {
      setConfig(prev => ({ ...prev, systemPrompt: newPrompt }))
    } else {
      setConfig(prev => ({ ...prev, userPrompt: newPrompt }))
    }
  }

  // Helper function to get all available variables from connected input nodes
  const getAvailableVariablesFromInputNodes = () => {
    const inputNodes = nodes.filter(node => node.type === 'input')
    const allVariables = []
    
    // Convert variable name to proper display name if name is missing
    const getDisplayName = (variable, name) => {
      if (name) return name
      // Convert camelCase/snake_case to proper display name
      return variable
        .replace(/([A-Z])/g, ' $1') // Add space before capital letters
        .replace(/_/g, ' ') // Replace underscores with spaces
        .replace(/^./, str => str.toUpperCase()) // Capitalize first letter
        .trim()
    }
    
    inputNodes.forEach(node => {
      if (node.data?.inputFields) {
        node.data.inputFields.forEach(field => {
          allVariables.push({
            variable: field.variable,
            name: getDisplayName(field.variable, field.name),
            type: field.type,
            sourceNode: node.data.label || node.id
          })
        })
      }
    })
    
    return allVariables
  }

  const getGenreSpecificProfessionalInput = (field, genre = 'general') => {
    const genreInputs = {
      // HEALTH GENRE - Professional medical/wellness focus
      health: {
        book_title: "ðŸ¥ The Complete Health Transformation Guide: Science-Based Strategies for Optimal Wellness",
        author_name: "Dr. Sarah Mitchell - Board-Certified Physician & Wellness Expert",
        author_bio: "Harvard-trained physician with 15+ years revolutionizing preventive medicine. Published researcher who's helped 50,000+ patients achieve breakthrough health outcomes.",
        custom_instructions: "ðŸŽ¯ Create evidence-based health content that transforms lives. Focus on actionable wellness strategies, medical insights, and sustainable lifestyle changes that deliver measurable health improvements.",
        health_focus: "prevention",
        age_group: "all_ages"
      },
      
      // TECHNICAL GENRE - Professional tech focus
      technical: {
        book_title: "âš¡ The Ultimate Developer's Mastery Guide: Advanced Programming Techniques That Dominate",
        author_name: "Alex Chen - Senior Software Architect & Tech Lead",
        author_bio: "Google-ex-Engineer with 12+ years building scalable systems. Open-source contributor who's mentored 5,000+ developers and created industry-standard frameworks.",
        custom_instructions: "ðŸ’» Deliver cutting-edge technical content that elevates developers to expert level. Focus on advanced programming concepts, system design, and real-world implementation strategies.",
        programming_language: "javascript",
        technical_level: "advanced"
      },
      
      // BUSINESS GENRE - Professional corporate focus
      business: {
        book_title: "ðŸš€ The Executive's Strategic Playbook: Market-Dominating Strategies for Unstoppable Growth",
        author_name: "Michael Rodriguez - Fortune 500 CEO & Strategic Advisor",
        author_bio: "Former McKinsey Partner with 20+ years transforming Fortune 500 companies. Serial entrepreneur who's built and sold 3 companies worth $100M+ combined.",
        custom_instructions: "ðŸ† Create strategic business content that drives exponential growth. Focus on market analysis, competitive positioning, and execution frameworks that deliver measurable ROI.",
        business_stage: "growth",
        market_size: "large"
      },
      
      // MARKETING GENRE - High-energy creative focus
      marketing: {
        book_title: "ðŸ”¥ The Viral Marketing Masterclass: Campaign Strategies That Break the Internet",
        author_name: "Jessica Park - Award-Winning Creative Director & Growth Hacker",
        author_bio: "Ex-Facebook Creative Lead with 10+ years launching viral campaigns. Growth hacker who's generated $500M+ in revenue for startups and Fortune 500 brands.",
        custom_instructions: "ðŸŽ¯ Create explosive marketing content that drives viral growth. Focus on creative campaign strategies, audience psychology, and conversion optimization that delivers massive ROI.",
        marketing_channel: "social_media",
        campaign_type: "viral"
      },
      
      // FINANCE GENRE - Professional financial focus
      finance: {
        book_title: "ðŸ’° The Wealth Builder's Blueprint: Investment Strategies That Create Generational Wealth",
        author_name: "Robert Kim - CFA & Investment Banking Executive",
        author_bio: "Goldman Sachs ex-VP with 15+ years managing $2B+ portfolios. Financial strategist who's helped 10,000+ clients achieve financial independence and generational wealth.",
        custom_instructions: "ðŸ’Ž Deliver sophisticated financial content that builds lasting wealth. Focus on investment strategies, risk management, and portfolio optimization that creates generational financial success.",
        financial_focus: "wealth_building",
        income_level: "high_net_worth"
      },
      
      // EDUCATION GENRE - Professional academic focus
      education: {
        book_title: "ðŸ“š The Learning Revolution: Advanced Study Techniques That Guarantee Academic Excellence",
        author_name: "Dr. Emily Watson - Educational Psychologist & Learning Specialist",
        author_bio: "Stanford PhD in Educational Psychology with 12+ years revolutionizing learning methodologies. Researcher who's helped 25,000+ students achieve academic breakthrough success.",
        custom_instructions: "ðŸŽ“ Create transformative educational content that accelerates learning. Focus on cognitive science, study optimization, and knowledge retention strategies that guarantee academic excellence.",
        education_level: "university",
        learning_style: "visual"
      }
    }
    
    // Get genre-specific input or fallback to general
    const genreData = genreInputs[genre] || genreInputs['business']
    return genreData[field.variable] || genreData[field.name] || `Enter ${field.name?.toLowerCase() || 'field'}`
  }

  const getProfessionalPlaceholder = (field) => {
    // Determine genre from the current flow context
    const genre = getCurrentFlowGenre()
    return getGenreSpecificProfessionalInput(field, genre)
  }

  const getCurrentFlowGenre = () => {
    // Extract genre from the current node's data or flow context
    if (node?.data?.label) {
      const label = node.data.label.toLowerCase()
      if (label.includes('health')) return 'health'
      if (label.includes('technical') || label.includes('programming')) return 'technical'
      if (label.includes('business') || label.includes('strategy')) return 'business'
      if (label.includes('marketing') || label.includes('campaign')) return 'marketing'
      if (label.includes('finance') || label.includes('financial')) return 'finance'
      if (label.includes('education') || label.includes('learning')) return 'education'
    }
    return 'business' // Default to business genre
  }

  const getGenreDisplayName = () => {
    const genre = getCurrentFlowGenre()
    const genreNames = {
      health: 'ðŸ¥ Health & Wellness',
      technical: 'âš¡ Technical & Programming', 
      business: 'ðŸš€ Business & Strategy',
      marketing: 'ðŸ”¥ Marketing & Growth',
      finance: 'ðŸ’° Finance & Investment',
      education: 'ðŸ“š Education & Learning'
    }
    return genreNames[genre] || 'ðŸš€ Business & Strategy'
  }

  const getGenreColor = () => {
    const genre = getCurrentFlowGenre()
    const genreColors = {
      health: 'bg-green-500',
      technical: 'bg-blue-500',
      business: 'bg-purple-500', 
      marketing: 'bg-orange-500',
      finance: 'bg-yellow-500',
      education: 'bg-indigo-500'
    }
    return genreColors[genre] || 'bg-purple-500'
  }

  useEffect(() => {
    if (node?.data) {
      // Use the node data as-is, preserving all configurations including selectedModels
      const cleanedData = { ...node.data }
      
      setConfig({ ...config, ...cleanedData })
      
      // Restore test input data for input nodes
      if (node.type === 'input') {
        // Always restore testInputEnabled from saved data
        if (cleanedData.testInputEnabled !== undefined) {
          setTestInputEnabled(cleanedData.testInputEnabled)
        }
        
        // Priority order: 1) Saved testInputValues, 2) testScenarios, 3) Generate defaults
        if (cleanedData.testInputValues && Object.keys(cleanedData.testInputValues).length > 0) {
          // Use saved test input values (highest priority)
          console.log('ðŸ” DEBUG: Restoring saved testInputValues:', cleanedData.testInputValues)
          setTestInputValues(cleanedData.testInputValues)
        } else if (cleanedData.testScenarios && cleanedData.testScenarios.length > 0) {
          // Use test scenarios as fallback
          const scenarioData = cleanedData.testScenarios[0].data
          console.log('ðŸ” DEBUG: Using testScenarios fallback:', scenarioData)
          setTestInputValues(scenarioData)
        } else if (cleanedData.inputFields && cleanedData.inputFields.length > 0) {
          // Generate default test input values based on input fields
          const defaultValues = generateDefaultTestInput(cleanedData.inputFields)
          console.log('ðŸ” DEBUG: Generating default test input:', defaultValues)
          setTestInputValues(defaultValues)
        }
        
        // Restore basic input values if they exist in saved data
        if (cleanedData.inputValues) {
          setInputValues(cleanedData.inputValues)
        } else {
          // Basic input starts empty
          setInputValues({})
        }
      }
      
      // Update connected nodes for condition nodes
      if (node.type === 'condition') {
        const connectedNodeIds = edges
          .filter(edge => edge.source === node.id)
          .map(edge => edge.target)
        
        const connectedNodesData = nodes
          .filter(n => connectedNodeIds.includes(n.id))
          .map(n => ({ id: n.id, label: n.data.label, type: n.type, data: n.data }))
        
        setConfig(prev => ({ ...prev, connectedNodes: connectedNodesData }))
      }
    }
  }, [node, nodes, edges])

  const loadAIProviders = async () => {
    try {
      setLoading(true)
      const { data: providers, error } = await supabase
        .from('ai_providers')
        .select('*')
        .eq('is_active', true)
      
      if (error) throw error
      
      setAvailableProviders(providers || [])
      
      // Auto-select random provider and load its models if no models are selected
      if (providers && providers.length > 0 && config.selectedModels.length === 0) {
        const randomProvider = providers[Math.floor(Math.random() * providers.length)]
        await loadModelsForProvider(randomProvider)
        
        // Auto-select random model from random provider
        setTimeout(async () => {
          const { data: models, error: modelError } = await supabase
            .from('ai_model_metadata')
            .select('*')
            .eq('is_active', true)
            .eq('key_name', randomProvider.name)
            .order('model_name', { ascending: true })
          
          if (!modelError && models && models.length > 0) {
            const randomModel = models[Math.floor(Math.random() * models.length)]
            const modelKey = `${randomProvider.name}:${randomModel.model_id}`
            
            setConfig(prev => ({
              ...prev,
              selectedModels: [modelKey]
            }))
            
            toast.success(`Auto-selected random model: ${randomModel.model_name}`)
          }
        }, 500) // Small delay to ensure models are loaded
      }
      
    } catch (error) {
      console.error('Error loading AI providers:', error)
      toast.error('Failed to load AI providers')
    } finally {
      setLoading(false)
    }
  }

  const loadModelsForProvider = async (provider) => {
    try {
      setLoading(true)
      
      console.log('ðŸ” Loading models for provider:', provider)
      
      // Use EXACT same logic as AIManagement loadActiveModels
      const { data, error } = await supabase
        .from('ai_model_metadata')
        .select('*')
        .eq('is_active', true)
        .eq('key_name', provider.name) // Filter by key_name directly in query
        .order('model_name', { ascending: true })

      if (error) throw error
      
      console.log(`ðŸŽ‰ Found ${data?.length || 0} models for ${provider.name} in ai_model_metadata`)
      
      const models = (data || []).map(model => ({
        id: model.model_id,
        name: model.model_name,
        // Calculate average cost for display
        avgCostPerMillion: model.input_cost_per_million && model.output_cost_per_million 
          ? ((model.input_cost_per_million + model.output_cost_per_million) / 2).toFixed(2)
          : 'N/A',
        inputCostPerMillion: model.input_cost_per_million,
        outputCostPerMillion: model.output_cost_per_million,
        contextWindow: model.context_window_tokens,
        specialties: model.specialties || [],
        pagesPerMillionTokens: model.pages_per_million_tokens,
        provider: model.provider,
        keyName: provider.name // Add the actual key name for proper model selection
      }))
      
      console.log(`ðŸ” Loaded ${models.length} models for ${provider.name}:`, models)
      setAvailableModels(prev => ({ ...prev, [provider.name]: models }))
      
    } catch (error) {
      console.error('Error loading models:', error)
      toast.error(`Failed to load models for ${provider.name}`)
      setAvailableModels(prev => ({ ...prev, [provider.name]: [] }))
    } finally {
      setLoading(false)
    }
  }

  const handleProviderSelect = async (provider) => {
    setSelectedProvider(provider.name) // Store the key name for model selection
    
    // Attempt to sync models before loading
    try {
      const apiKey = await getApiKeyForProvider(provider.provider)
      if (apiKey) {
        await aiModelDiscoveryService.discoverModelsForProvider(provider.provider, apiKey)
      }
    } catch (error) {
      console.error('Model sync failed:', error)
    }
    
    // Load models after potential sync - pass the provider object as is
    loadModelsForProvider(provider)
  }

  // Helper function to get API key for a provider
  const getApiKeyForProvider = async (providerName) => {
    const { data: providers, error } = await supabase
      .from('ai_providers')
      .select('*')
      .eq('name', providerName)
      .eq('is_active', true)
      .single()

    if (error || !providers) {
      console.error('Failed to fetch API key:', error)
      return null
    }

    return providers.api_key
  }

  const addModel = (provider, model) => {
    // Use the actual provider name from database, not the provider parameter
    const providerName = selectedProvider || provider
    const modelKey = `${providerName}:${model.id}`
    
    if (!config.selectedModels.includes(modelKey)) {
      setConfig({
        ...config,
        selectedModels: [...config.selectedModels, modelKey]
      })
      toast.success(`${model.name} added`)
    }
    // Close the dropdown after selecting a model
    setSelectedProvider('')
  }

  const removeModel = (modelKey) => {
    setConfig({
      ...config,
      selectedModels: config.selectedModels.filter(m => m !== modelKey)
    })
    toast.success('Model removed')
  }

  // Save node to palette
  const saveToPalette = async () => {
    if (!config.label?.trim()) {
      toast.error('Node label is required')
      return
    }

    try {
      const nodeData = {
        node_id: `custom_${node.type}_${Date.now()}`,
        name: config.label,
        description: config.description || `Custom ${node.type} node`,
        type: node.type,
        category: node.masterCategory || node.type,
        sub_category: node.type === 'process' ? 'custom' : null,
        role: node.role || `custom_${node.type}_${Date.now()}`,
        icon: node.icon || 'âš™ï¸',
        gradient: node.gradient || 'from-gray-500 to-gray-700',
        is_ai_enabled: config.aiEnabled || false,
        configuration: {
          ...config,
          testInputEnabled: testInputEnabled,
          testInputValues: testInputValues,
          inputValues: inputValues
        }
      }

      const { data, error } = await supabase
        .from('node_palettes')
        .insert([nodeData])
        .select()

      if (error) throw error

      toast.success(`Node "${config.label}" saved to palette!`)
      
      // Also save to current flow
      handleSave()
      
    } catch (error) {
      console.error('Error saving to palette:', error)
      toast.error('Failed to save node to palette: ' + error.message)
    }
  }

  const handleSave = () => {
    if (!config.label?.trim()) {
      toast.error('Node label is required')
      return
    }

    // Validate based on node type
    if (node?.type === 'input' && config.inputFields.length === 0) {
      toast.error('Input node must have at least one input field')
      return
    }

    if (node?.type === 'condition' && config.conditions.length === 0) {
      toast.error('Condition node must have at least one condition')
      return
    }

    if (config.aiEnabled && config.selectedModels.length === 0) {
      toast.error('At least one AI model must be selected when AI is enabled')
      return
    }

    // For input nodes, include test input values and basic input values in the saved config
    if (node?.type === 'input') {
      const configWithInputValues = {
        ...config,
        testInputEnabled: testInputEnabled,
        testInputValues: testInputValues,
        inputValues: inputValues
      }
      console.log('ðŸ’¾ Saving input node with input values:')
      console.log('  - Test input enabled:', testInputEnabled)
      console.log('  - Test input values:', testInputValues)
      console.log('  - Basic input values:', inputValues)
      console.log('  - Config keys:', Object.keys(configWithInputValues))
      onSave(configWithInputValues)
    } else {
      onSave(config)
    }
  }

  const addInputField = () => {
    setConfig({
      ...config,
      inputFields: [
        ...config.inputFields,
        { 
          id: Date.now(), 
          name: '', 
          type: 'text', 
          required: true, 
          options: [],
          variable: '',
          description: ''
        }
      ]
    })
  }

  const updateInputField = (index, field) => {
    const updatedFields = [...config.inputFields]
    updatedFields[index] = { ...updatedFields[index], ...field }
    setConfig({ ...config, inputFields: updatedFields })
    
    // Auto-sync new fields to Test Input
    if (field.variable && !testInputValues[field.variable]) {
      const fieldName = field.variable || field.name
      let defaultValue = ''
      
      if (field.type === 'select' && getFieldOptions(field)?.length > 0) {
        const options = getFieldOptions(field)
        if (field.multiple) {
          defaultValue = options.slice(0, 2).map(opt => typeof opt === 'string' ? opt : opt.value)
        } else {
          defaultValue = typeof options[0] === 'string' ? options[0] : options[0]?.value || ''
        }
      } else if (field.type === 'checkbox') {
        defaultValue = field.required || false
      } else if (field.type === 'textarea') {
        defaultValue = field.placeholder || `Enter ${field.name || fieldName}`
      } else if (field.type === 'text') {
        defaultValue = field.placeholder || `Enter ${field.name || fieldName}`
      } else if (field.type === 'number') {
        defaultValue = field.min || 1000
      }
      
      setTestInputValues(prev => ({
        ...prev,
        [fieldName]: defaultValue
      }))
    }
  }

  const removeInputField = (index) => {
    setConfig({
      ...config,
      inputFields: config.inputFields.filter((_, i) => i !== index)
    })
  }

  // Condition management
  const addCondition = () => {
    setConfig({
      ...config,
      conditions: [
        ...config.conditions,
        {
          id: Date.now(),
          field: '',
          operator: 'equals',
          value: '',
          action: '',
          description: ''
        }
      ]
    })
  }

  const updateCondition = (index, condition) => {
    const updatedConditions = [...config.conditions]
    updatedConditions[index] = { ...updatedConditions[index], ...condition }
    setConfig({ ...config, conditions: updatedConditions })
  }

  const removeCondition = (index) => {
    setConfig({
      ...config,
      conditions: config.conditions.filter((_, i) => i !== index)
    })
  }

  // Add condition templates for easier setup
  const addConditionTemplate = (templateType) => {
    let template = {}
    
    switch (templateType) {
      case 'ai_validation':
        template = {
          id: Date.now(),
          field: 'ai_evaluation_result',
          operator: 'ai_evaluate',
          value: 'validation_passed',
          description: 'AI Strategy Validation',
          trueAction: 'validation_passed',
          falseAction: 'validation_failed'
        }
        break
      case 'content_check':
        template = {
          id: Date.now(),
          field: 'content_completeness',
          operator: 'equals',
          value: 'complete',
          description: 'Content Completeness Check',
          trueAction: 'content_complete',
          falseAction: 'content_incomplete'
        }
        break
      case 'user_preference':
        template = {
          id: Date.now(),
          field: 'user_preference',
          operator: 'equals',
          value: 'advanced',
          description: 'User Preference Check',
          trueAction: 'advanced_route',
          falseAction: 'basic_route'
        }
        break
      case 'custom':
        template = {
          id: Date.now(),
          field: '',
          operator: 'equals',
          value: '',
          description: 'Custom Condition',
          trueAction: '',
          falseAction: ''
        }
        break
    }
    
    setConfig({
      ...config,
      conditions: [
        ...(config.conditions || []),
        template
      ]
    })
  }

  // Main component render
  if (!isOpen) return null

  const tabs = [
    { id: 'basic', label: 'Basic Info', icon: Settings },
    { id: 'instructions', label: 'Instructions', icon: FileText },
    { id: 'ai', label: 'AI Integration', icon: Brain },
    { id: 'advanced', label: 'Advanced', icon: Zap },
    { id: 'variables', label: 'Variables', icon: FileText },
    { id: 'test', label: 'Test Input', icon: RefreshCw },
  ]

  return (
    <div className="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50">
      <div className="bg-gray-800 rounded-2xl border border-gray-700 p-4 max-w-4xl w-full mx-4 max-h-[90vh] overflow-y-auto">
        {/* Header */}
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-2">
            <div className="p-2 bg-primary/20 rounded-lg">
              {node?.type === 'input' && <FileText className="w-5 h-5 text-blue-400" />}
              {node?.type === 'process' && <Brain className="w-5 h-5 text-green-400" />}
              {node?.type === 'condition' && <GitBranch className="w-5 h-5 text-yellow-400" />}
              {node?.type === 'output' && <CheckCircle className="w-5 h-5 text-purple-400" />}
            </div>
            <div>
              <h2 className="text-lg font-semibold text-white">
                {node?.type?.charAt(0).toUpperCase() + node?.type?.slice(1)} Node Configuration
              </h2>
              <p className="text-xs text-gray-400">Configure node properties and behavior</p>
            </div>
          </div>
          <div className="flex items-center gap-2">
            <button
              onClick={onDelete}
              className="text-red-400 hover:text-red-300 transition-colors p-2 hover:bg-red-500/10 rounded-lg"
              title="Delete Node"
            >
              <Trash2 className="w-5 h-5" />
            </button>
            <button
              onClick={onClose}
              className="p-2 hover:bg-gray-700 rounded-full transition-colors"
            >
              <X className="w-5 h-5 text-gray-400" />
            </button>
          </div>
        </div>

        {/* Tabs */}
        <div className="flex space-x-1 mb-4 bg-gray-700 rounded-lg p-1">
          {tabs.map((tab) => {
            const Icon = tab.icon
            return (
              <button
                key={tab.id}
                onClick={() => setActiveTab(tab.id)}
                className={`flex items-center gap-1 px-3 py-2 rounded-md text-xs font-medium transition-colors ${
                  activeTab === tab.id
                    ? 'bg-primary text-white'
                    : 'text-gray-300 hover:text-white hover:bg-gray-600'
                }`}
              >
                <Icon className="w-3 h-3" />
                {tab.label}
              </button>
            )
          })}
        </div>

        {/* Tab Content */}
        <div className="space-y-6 max-h-96 overflow-y-auto">
          {/* Basic Info Tab */}
          {activeTab === 'basic' && (
            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-200 mb-2">Node Label</label>
                <input
                  type="text"
                  value={config.label || ''}
                  onChange={(e) => setConfig({ ...config, label: e.target.value })}
                  className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white placeholder-gray-400"
                  placeholder="Enter node label"
                />
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-200 mb-2">Description</label>
                <textarea
                  value={config.description || ''}
                  onChange={(e) => setConfig({ ...config, description: e.target.value })}
                  className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white placeholder-gray-400 h-20"
                  placeholder="Enter node description"
                />
              </div>

              {/* Input Fields for Input Nodes */}
              {node?.type === 'input' && (
                <div>
                  <div className="flex items-center justify-between mb-3">
                    <h3 className="text-lg font-medium text-white">Input Fields</h3>
                    <button
                      onClick={addInputField}
                      className="flex items-center gap-2 px-3 py-1 bg-primary rounded-lg text-white text-sm"
                    >
                      <Plus className="w-4 h-4" />
                      Add Field
                    </button>
                  </div>
                  
                  <div className="space-y-3">
                    {config.inputFields?.map((field, index) => (
                      <div key={field.id} className="bg-gray-700/50 rounded-lg p-4 space-y-3">
                        <div className="flex items-center justify-between">
                          <h4 className="text-sm font-medium text-white">Field {index + 1}</h4>
                          <button
                            onClick={() => removeInputField(index)}
                            className="text-red-400 hover:text-red-300 text-sm"
                          >
                            <Trash2 className="w-4 h-4" />
                          </button>
                        </div>
                        
                        <div className="grid grid-cols-3 gap-3">
                          <div>
                            <label className="block text-xs text-gray-300 mb-1">Field Name</label>
                            <input
                              type="text"
                              value={field.name}
                              onChange={(e) => updateInputField(index, { name: e.target.value })}
                              className="w-full bg-gray-600 border border-gray-500 rounded px-3 py-1 text-sm text-white"
                              placeholder="Field name"
                            />
                          </div>
                          <div>
                            <label className="block text-xs text-gray-300 mb-1">Type</label>
                            <select
                              value={field.type}
                              onChange={(e) => updateInputField(index, { type: e.target.value })}
                              className="w-full bg-gray-600 border border-gray-500 rounded px-3 py-1 text-sm text-white"
                            >
                              <option value="text">Text</option>
                              <option value="textarea">Textarea</option>
                              <option value="select">Select</option>
                              <option value="number">Number</option>
                              <option value="boolean">Boolean</option>
                            </select>
                          </div>
                          <div>
                            <label className="block text-xs text-gray-300 mb-1">Variable</label>
                            <input
                              type="text"
                              value={field.variable}
                              onChange={(e) => updateInputField(index, { variable: e.target.value })}
                              className="w-full bg-gray-600 border border-gray-500 rounded px-3 py-1 text-sm text-white"
                              placeholder="Variable name"
                            />
                          </div>
                        </div>

                        {field.type === 'select' && (
                          <div>
                            <label className="block text-xs text-gray-300 mb-1">Options Source</label>
                            <select
                              onChange={(e) => {
                                const source = e.target.value
                                let options = []
                                
                                if (source === 'bookTypes') options = inputOptions?.bookTypes || []
                                else if (source === 'niches') options = inputOptions?.niches || []
                                else if (source === 'tones') options = inputOptions?.tones || []
                                else if (source === 'accents') options = inputOptions?.accents || []
                                else if (source === 'wordCounts') options = inputOptions?.wordCounts || []
                                else if (source === 'chapterCounts') options = inputOptions?.chapterCounts || []
                                else if (source === 'writingStyles') options = inputOptions?.writingStyles || []
                                else if (source === 'targetAudiences') options = inputOptions?.targetAudiences || []
                                else if (source === 'genres') options = inputOptions?.genres || []
                                else if (source === 'outputFormats') options = inputOptions?.outputFormats || []
                                else if (source === 'publishingFormats') options = inputOptions?.publishingFormats || []
                                else if (source === 'contentDepths') options = inputOptions?.contentDepths || []
                                else if (source === 'researchLevels') options = inputOptions?.researchLevels || []
                                else if (source === 'businessModels') options = inputOptions?.businessModels || []
                                else if (source === 'programmingLanguages') options = inputOptions?.programmingLanguages || []
                                else if (source === 'technicalLevels') options = inputOptions?.technicalLevels || []
                                else if (source === 'implementationTypes') options = inputOptions?.implementationTypes || []
                                else if (source === 'marketingChannels') options = inputOptions?.marketingChannels || []
                                else if (source === 'campaignObjectives') options = inputOptions?.campaignObjectives || []
                                else if (source === 'healthFocuses') options = inputOptions?.healthFocuses || []
                                else if (source === 'ageGroups') options = inputOptions?.ageGroups || []
                                else if (source === 'fitnessLevels') options = inputOptions?.fitnessLevels || []
                                else if (source === 'educationLevels') options = inputOptions?.educationLevels || []
                                else if (source === 'learningStyles') options = inputOptions?.learningStyles || []
                                else if (source === 'subjectAreas') options = inputOptions?.subjectAreas || []
                                else if (source === 'careerPaths') options = inputOptions?.careerPaths || []
                                else if (source === 'brandingStyles') options = inputOptions?.brandingStyles || []
                                else if (source === 'bookSizes') options = inputOptions?.bookSizes || []
                                else if (source === 'typographyStyles') options = inputOptions?.typographyStyles || []
                                else if (source === 'coverDesigns') options = inputOptions?.coverDesigns || []
                                else if (source === 'emotionalTones') options = inputOptions?.emotionalTones || []
                                else if (source === 'mindsetFocuses') options = inputOptions?.mindsetFocuses || []
                                
                                updateInputField(index, { options, optionsSource: source })
                              }}
                              className="w-full bg-gray-600 border border-gray-500 rounded px-3 py-1 text-sm text-white"
                            >
                              <option value="">Select options source</option>
                              <option value="bookTypes">Book Types</option>
                              <option value="niches">Niches</option>
                              <option value="tones">Tones</option>
                              <option value="accents">Accents</option>
                              <option value="wordCounts">Word Counts</option>
                              <option value="chapterCounts">Chapter Counts</option>
                              <option value="writingStyles">Writing Styles</option>
                              <option value="targetAudiences">Target Audiences</option>
                              <option value="genres">Genres</option>
                              <option value="outputFormats">Output Formats</option>
                              <option value="publishingFormats">Publishing Formats</option>
                              <option value="contentDepths">Content Depths</option>
                              <option value="researchLevels">Research Levels</option>
                              <option value="businessModels">Business Models</option>
                              <option value="programmingLanguages">Programming Languages</option>
                              <option value="technicalLevels">Technical Levels</option>
                              <option value="implementationTypes">Implementation Types</option>
                              <option value="marketingChannels">Marketing Channels</option>
                              <option value="campaignObjectives">Campaign Objectives</option>
                              <option value="healthFocuses">Health Focuses</option>
                              <option value="ageGroups">Age Groups</option>
                              <option value="fitnessLevels">Fitness Levels</option>
                              <option value="educationLevels">Education Levels</option>
                              <option value="learningStyles">Learning Styles</option>
                              <option value="subjectAreas">Subject Areas</option>
                              <option value="careerPaths">Career Paths</option>
                              <option value="brandingStyles">Branding Styles</option>
                              <option value="bookSizes">Book Sizes</option>
                              <option value="typographyStyles">Typography Styles</option>
                              <option value="coverDesigns">Cover Designs</option>
                              <option value="emotionalTones">Emotional Tones</option>
                              <option value="mindsetFocuses">Mindset Focuses</option>
                            </select>
                        </div>
                      )}
                    </div>
                    ))}
                  </div>

                  {/* Basic Input Values - Framework Input Fields */}
                  {config.inputFields && Array.isArray(config.inputFields) && config.inputFields.length > 0 && (
                    <div className="space-y-4 mt-6">
                      <h4 className="text-md font-semibold text-gray-200 border-b border-gray-600 pb-2">
                        Basic Input Values ({config.inputFields.length} fields)
                      </h4>
                      <div className="grid grid-cols-2 gap-4">
                        {config.inputFields.map((field, index) => {
                          // Handle conditional field display
                          if (field.conditional) {
                            const condition = field.conditional
                            if (condition.includes('book_size === "custom"')) {
                              const bookSizeValue = inputValues.book_size || inputValues[field.variable] || ''
                              if (bookSizeValue !== 'custom') {
                                return null // Don't render this field
                              }
                            }
                          }
                          
                          return (
                          <div key={field.id || index} className={field.fullWidth ? 'col-span-2' : ''}>
                            <label className="block text-sm font-medium text-gray-200 mb-2">
                              {field.name} {field.required && <span className="text-red-400">*</span>}
                            </label>
                            
                            {field.type === 'text' && (
                              <input
                                type="text"
                                value={inputValues[field.variable] || inputValues[field.name] || ''}
                                onChange={(e) => setInputValues({
                                  ...inputValues, 
                                  [field.variable]: e.target.value,
                                  [field.name]: e.target.value
                                })}
                                placeholder={getProfessionalPlaceholder(field)}
                                className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white"
                              />
                            )}
                            
                            {field.type === 'textarea' && (
                              <textarea
                                value={inputValues[field.variable] || inputValues[field.name] || ''}
                                onChange={(e) => setInputValues({
                                  ...inputValues, 
                                  [field.variable]: e.target.value,
                                  [field.name]: e.target.value
                                })}
                                placeholder={getProfessionalPlaceholder(field)}
                                rows={field.rows || 3}
                                className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white"
                              />
                            )}
                            
                            {field.type === 'select' && (
                              <select
                                value={inputValues[field.variable] || inputValues[field.name] || ''}
                                onChange={(e) => {
                                  const value = field.multiple ? 
                                    Array.from(e.target.selectedOptions, option => option.value) : 
                                    e.target.value
                                  setInputValues({
                                    ...inputValues, 
                                    [field.variable]: value,
                                    [field.name]: value
                                  })
                                }}
                                multiple={field.multiple}
                                className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white"
                              >
                                <option value="">ðŸŽ¯ Choose Your {field.name || 'Option'}</option>
                                {getFieldOptions(field)?.map((option, optIndex) => (
                                  <option key={optIndex} value={typeof option === 'string' ? option : option.value}>
                                    {typeof option === 'string' ? option : (option.label || option.name || option.value || option)}
                                  </option>
                                ))}
                              </select>
                            )}
                            
                            {field.type === 'boolean' && (
                              <div className="flex items-center space-x-2">
                                <input
                                  type="checkbox"
                                  checked={inputValues[field.variable] || inputValues[field.name] || false}
                                  onChange={(e) => setInputValues({
                                    ...inputValues, 
                                    [field.variable]: e.target.checked,
                                    [field.name]: e.target.checked
                                  })}
                                  className="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500"
                                />
                                <span className="text-sm text-gray-300">
                                  {field.name || field.variable}
                                </span>
                              </div>
                            )}
                            
                            {field.type === 'number' && (
                              <input
                                type="number"
                                value={inputValues[field.variable] || inputValues[field.name] || ''}
                                onChange={(e) => setInputValues({
                                  ...inputValues, 
                                  [field.variable]: e.target.value,
                                  [field.name]: e.target.value
                                })}
                                placeholder={getProfessionalPlaceholder(field)}
                                min={field.min || 0}
                                max={field.max || 1000000}
                                className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white"
                              />
                            )}
                          </div>
                          )
                        })}
                      </div>
                    </div>
                  )}
                </div>
              )}

              {/* Enhanced Conditions for Condition Nodes */}
              {node?.type === 'condition' && (
                <div className="space-y-6">
                  <div className="flex items-center justify-between mb-3">
                    <h3 className="text-lg font-medium text-white">Smart Condition Logic</h3>
                    <button
                      onClick={addCondition}
                      className="flex items-center gap-2 px-3 py-1 bg-primary rounded-lg text-white text-sm"
                    >
                      <Plus className="w-4 h-4" />
                      Add Condition
                    </button>
                  </div>
                  
                  <div className="space-y-4">
                    {config.conditions?.map((condition, index) => (
                      <div key={condition.id} className="bg-gray-700/30 border border-gray-600 rounded-lg p-5 space-y-4">
                        <div className="flex items-center justify-between">
                          <h4 className="text-md font-medium text-white flex items-center gap-2">
                            <GitBranch className="w-4 h-4 text-yellow-400" />
                            Condition {index + 1}
                          </h4>
                          <button
                            onClick={() => removeCondition(index)}
                            className="text-red-400 hover:text-red-300 transition-colors"
                          >
                            <Trash2 className="w-4 h-4" />
                          </button>
                        </div>
                        
                        <div className="grid grid-cols-3 gap-3">
                          <div>
                            <label className="block text-xs text-gray-300 mb-1">Field/Variable</label>
                            <input
                              type="text"
                              value={condition.field}
                              onChange={(e) => updateCondition(index, { field: e.target.value })}
                              className="w-full bg-gray-600 border border-gray-500 rounded px-3 py-2 text-sm text-white"
                              placeholder="user_wants_images"
                            />
                          </div>
                          <div>
                            <label className="block text-xs text-gray-300 mb-1">Operator</label>
                            <select
                              value={condition.operator}
                              onChange={(e) => updateCondition(index, { operator: e.target.value })}
                              className="w-full bg-gray-600 border border-gray-500 rounded px-3 py-2 text-sm text-white"
                            >
                              <option value="equals">Equals</option>
                              <option value="not_equals">Not Equals</option>
                              <option value="contains">Contains</option>
                              <option value="greater_than">Greater Than</option>
                              <option value="less_than">Less Than</option>
                              <option value="exists">Exists</option>
                              <option value="ai_evaluate">AI Evaluate</option>
                            </select>
                          </div>
                          <div>
                            <label className="block text-xs text-gray-300 mb-1">Value</label>
                            <input
                              type="text"
                              value={condition.value}
                              onChange={(e) => updateCondition(index, { value: e.target.value })}
                              className="w-full bg-gray-600 border border-gray-500 rounded px-3 py-2 text-sm text-white"
                              placeholder="true, false, contains text"
                            />
                          </div>
                        </div>

                        {/* TRUE Action Section */}
                        <div className="bg-green-900/20 border border-green-600/30 rounded-lg p-4">
                          <div className="flex items-center gap-2 mb-3">
                            <div className="w-3 h-3 bg-green-500 rounded-full"></div>
                            <h5 className="font-medium text-green-400">When TRUE (Yes)</h5>
                          </div>
                          
                          <div className="space-y-3">
                            <div>
                              <label className="block text-xs text-gray-300 mb-1">Action Type</label>
                              <select
                                value={condition.trueAction?.type || 'continue'}
                                onChange={(e) => updateCondition(index, { 
                                  trueAction: { ...condition.trueAction, type: e.target.value }
                                })}
                                className="w-full bg-gray-600 border border-gray-500 rounded px-3 py-2 text-sm text-white"
                              >
                                <option value="continue">Continue to Next Node</option>
                                <option value="skip_to">Skip to Specific Node</option>
                                <option value="generate_image">Generate Image</option>
                                <option value="generate_content">Generate Additional Content</option>
                                <option value="enhance_content">Enhance Existing Content</option>
                                <option value="research">Perform Research</option>
                              </select>
                            </div>

                            {condition.trueAction?.type === 'generate_image' && (
                              <div>
                                <label className="block text-xs text-gray-300 mb-1">Image Generation Prompt</label>
                                <textarea
                                  value={condition.trueAction?.prompt || 'Create a stunning, professional book cover image that captures the essence of this book. Style: modern, visually striking, genre-appropriate. Include the book title prominently in an elegant, readable font. Use colors and imagery that reflect the book\'s tone, theme, and target audience. Ensure high visual impact and commercial appeal. Resolution: 1600x2400px for optimal print and digital quality.'}
                                  onChange={(e) => updateCondition(index, { 
                                    trueAction: { ...condition.trueAction, prompt: e.target.value }
                                  })}
                                  rows={4}
                                  className="w-full bg-gray-600 border border-gray-500 rounded px-3 py-2 text-sm text-white"
                                  placeholder="Professional image generation prompt..."
                                />
                              </div>
                            )}

                            {condition.trueAction?.type === 'generate_content' && (
                              <div>
                                <label className="block text-xs text-gray-300 mb-1">Content Generation Prompt</label>
                                <textarea
                                  value={condition.trueAction?.prompt || 'Generate high-quality, engaging content that seamlessly integrates with the existing narrative. Maintain perfect consistency with the established tone, writing style, character development, and thematic elements. Ensure the content adds meaningful value, advances the plot or information flow, and meets professional publishing standards. Word count should be appropriate for the context and purpose within the overall work.'}
                                  onChange={(e) => updateCondition(index, { 
                                    trueAction: { ...condition.trueAction, prompt: e.target.value }
                                  })}
                                  rows={4}
                                  className="w-full bg-gray-600 border border-gray-500 rounded px-3 py-2 text-sm text-white"
                                  placeholder="Professional content generation prompt..."
                                />
                              </div>
                            )}

                            <div>
                              <label className="block text-xs text-gray-300 mb-1">AI Instructions for TRUE Path</label>
                              <textarea
                                value={condition.trueAction?.instructions || 'Execute this action with precision and excellence. When the condition evaluates to TRUE, proceed with full confidence and attention to detail. Ensure all outputs meet the highest professional standards, maintain consistency with the overall project goals, and deliver exceptional quality that exceeds user expectations. Focus on creating value and advancing the workflow objectives effectively.'}
                                onChange={(e) => updateCondition(index, { 
                                  trueAction: { ...condition.trueAction, instructions: e.target.value }
                                })}
                                rows={3}
                                className="w-full bg-gray-600 border border-gray-500 rounded px-3 py-2 text-sm text-white"
                                placeholder="Professional instructions for TRUE scenario..."
                              />
                            </div>
                          </div>
                        </div>

                        {/* FALSE Action Section */}
                        <div className="bg-red-900/20 border border-red-600/30 rounded-lg p-4">
                          <div className="flex items-center gap-2 mb-3">
                            <div className="w-3 h-3 bg-red-500 rounded-full"></div>
                            <h5 className="font-medium text-red-400">When FALSE (No)</h5>
                          </div>
                          
                          <div className="space-y-3">
                            <div>
                              <label className="block text-xs text-gray-300 mb-1">Action Type</label>
                              <select
                                value={condition.falseAction?.type || 'skip_to_output'}
                                onChange={(e) => updateCondition(index, { 
                                  falseAction: { ...condition.falseAction, type: e.target.value }
                                })}
                                className="w-full bg-gray-600 border border-gray-500 rounded px-3 py-2 text-sm text-white"
                              >
                                <option value="skip_to_output">Skip to Final Output</option>
                                <option value="alternative_path">Take Alternative Path</option>
                                <option value="use_fallback">Use Fallback Content</option>
                                <option value="prompt_user">Request User Input</option>
                                <option value="retry_modified">Retry with Modifications</option>
                              </select>
                            </div>

                            <div>
                              <label className="block text-xs text-gray-300 mb-1">AI Instructions for FALSE Path</label>
                              <textarea
                                value={condition.falseAction?.instructions || 'Handle this alternative path gracefully and professionally. When the condition evaluates to FALSE, ensure the workflow continues smoothly without compromising quality or user experience. Implement appropriate fallback strategies, maintain consistency with project objectives, and deliver valuable results even when taking the alternative route. Focus on creating a seamless, high-quality experience regardless of the path taken.'}
                                onChange={(e) => updateCondition(index, { 
                                  falseAction: { ...condition.falseAction, instructions: e.target.value }
                                })}
                                rows={3}
                                className="w-full bg-gray-600 border border-gray-500 rounded px-3 py-2 text-sm text-white"
                                placeholder="Professional instructions for FALSE scenario..."
                              />
                            </div>
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {/* Preview Node Configuration */}
              {node?.type === 'preview' && (
                <div className="space-y-6">
                  <div className="flex items-center justify-between mb-3">
                    <h3 className="text-lg font-medium text-white">Preview Configuration</h3>
                    <div className="flex items-center gap-2 text-sm text-gray-400">
                      <Eye className="w-4 h-4" />
                      <span>Customer Approval Required</span>
                    </div>
                  </div>
                  
                  {/* Max Attempts */}
                  <div>
                    <label className="block text-sm font-medium text-gray-200 mb-2">
                      Maximum Attempts
                    </label>
                    <div className="flex items-center gap-3">
                      <input
                        type="number"
                        min="1"
                        max="10"
                        value={config.maxAttempts || 3}
                        onChange={(e) => setConfig(prev => ({ ...prev, maxAttempts: parseInt(e.target.value) || 3 }))}
                        className="w-20 px-3 py-2 bg-gray-800 border border-gray-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-cyan-500"
                      />
                      <span className="text-gray-400 text-sm">
                        {config.maxAttempts === 1 ? 'Single attempt only' : 
                         config.maxAttempts >= 10 ? 'Unlimited attempts' : 
                         `${config.maxAttempts} attempts maximum`}
                      </span>
                    </div>
                  </div>

                  {/* Preview Length */}
                  <div>
                    <label className="block text-sm font-medium text-gray-200 mb-2">
                      Preview Length
                    </label>
                    <select
                      value={config.previewLength || '1 chapter'}
                      onChange={(e) => setConfig(prev => ({ ...prev, previewLength: e.target.value }))}
                      className="w-full px-3 py-2 bg-gray-800 border border-gray-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-cyan-500"
                    >
                      <option value="1 page">1 page</option>
                      <option value="2 pages">2 pages</option>
                      <option value="1 chapter">1 chapter</option>
                      <option value="2 chapters">2 chapters</option>
                      <option value="500 words">500 words</option>
                      <option value="1000 words">1000 words</option>
                      <option value="custom">Custom length</option>
                    </select>
                  </div>

                  {/* Custom Length Input */}
                  {config.previewLength === 'custom' && (
                    <div>
                      <label className="block text-sm font-medium text-gray-200 mb-2">
                        Custom Preview Length
                      </label>
                      <input
                        type="text"
                        placeholder="e.g., 3 pages, 1500 words, half chapter"
                        value={config.customPreviewLength || ''}
                        onChange={(e) => setConfig(prev => ({ ...prev, customPreviewLength: e.target.value }))}
                        className="w-full px-3 py-2 bg-gray-800 border border-gray-600 rounded-lg text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-cyan-500"
                      />
                    </div>
                  )}

                  {/* Approval Settings */}
                  <div className="bg-cyan-500/10 border border-cyan-500/30 rounded-lg p-4">
                    <div className="flex items-center gap-2 mb-2">
                      <CheckCircle className="w-5 h-5 text-cyan-400" />
                      <h4 className="font-medium text-white">Approval Workflow</h4>
                    </div>
                    <div className="space-y-2 text-sm text-gray-300">
                      <p>â€¢ Customer reviews generated preview content</p>
                      <p>â€¢ Can approve to continue or reject with feedback</p>
                      <p>â€¢ Rejection triggers regeneration with customer input</p>
                      <p>â€¢ Workflow continues after approval or max attempts reached</p>
                    </div>
                  </div>
                </div>
              )}

              {/* Connected Nodes Display for Condition Nodes */}
              {node?.type === 'condition' && config.connectedNodes?.length > 0 && (
                <div>
                  <label className="block text-sm font-medium text-gray-200 mb-2">Connected Nodes</label>
                  <div className="space-y-2">
                    {config.connectedNodes.map((connectedNode) => (
                      <div key={connectedNode.id} className="bg-gray-700/50 rounded-lg p-3">
                        <div className="flex items-center gap-2">
                          <div className={`w-3 h-3 rounded-full ${
                            connectedNode.type === 'input' ? 'bg-blue-400' :
                            connectedNode.type === 'process' ? 'bg-green-400' :
                            connectedNode.type === 'condition' ? 'bg-yellow-400' :
                            connectedNode.type === 'preview' ? 'bg-cyan-400' : 'bg-purple-400'
                          }`} />
                          <span className="text-white font-medium">{connectedNode.label}</span>
                          <span className="text-gray-400 text-sm">({connectedNode.type})</span>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </div>
          )}

          {/* Instructions Tab */}
          {activeTab === 'instructions' && (
            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-200 mb-2">Node Instructions</label>
                <textarea
                  value={config.inputInstructions || getNodeInstructions(node?.type, node?.role || node?.data?.role)}
                  onChange={(e) => setConfig({ ...config, inputInstructions: e.target.value })}
                  className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white placeholder-gray-400 h-32"
                  placeholder="Technical processing instructions for workflow execution..."
                />
                <p className="text-xs text-gray-400 mt-2">
                  Technical instructions for workflow engine on how to process this node's data and execute its function
                </p>
              </div>
              
              <div>
                <label className="block text-sm font-medium text-gray-200 mb-2">Expert System Prompt</label>
                <textarea
                  value={config.systemPrompt || getNodeConfiguration(node?.type, node?.role || node?.data?.role)?.systemPrompt || ''}
                  onChange={(e) => setConfig({ ...config, systemPrompt: e.target.value })}
                  className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white placeholder-gray-400 h-32"
                  placeholder="System prompt for AI model..."
                />
                <p className="text-xs text-gray-400 mt-2">
                  System-level prompt that defines the AI's role and behavior
                </p>
              </div>
              
              <div>
                <label className="block text-sm font-medium text-gray-200 mb-2">User Prompt Template</label>
                <textarea
                  value={config.userPrompt || getDefaultUserPrompt(node?.type)}
                  onChange={(e) => setConfig({ ...config, userPrompt: e.target.value })}
                  className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white placeholder-gray-400 h-32"
                  placeholder="Professional user prompt template with dynamic variables..."
                />
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-200 mb-2">Previous Node Passover (Data Storage)</label>
                <textarea
                  value={config.previousNodePassover || ''}
                  onChange={(e) => setConfig({ ...config, previousNodePassover: e.target.value })}
                  className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white placeholder-gray-400 h-32"
                  placeholder="JSON data from previous node will be temporarily stored here during AI processing..."
                  readOnly
                />
                <p className="text-xs text-gray-400 mt-2">
                  DYNAMIC STORAGE: Workflow engine stores previous node's JSON output here temporarily while this node processes with AI, then combines both for next node passover
                </p>
              </div>

            </div>
          )}

          {/* AI Integration Tab */}
          {activeTab === 'ai' && (
            <div className="space-y-6">
              {/* AI Enable Toggle */}
              <div className="flex items-center justify-between">
                <div>
                  <h3 className="text-lg font-medium text-white">AI Integration</h3>
                  <p className="text-sm text-gray-400">Configure AI models and processing</p>
                </div>
                <label className="relative inline-flex items-center cursor-pointer">
                  <input
                    type="checkbox"
                    checked={config.aiEnabled}
                    onChange={(e) => setConfig({ ...config, aiEnabled: e.target.checked })}
                    className="sr-only peer"
                  />
                  <div className="w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-primary"></div>
                </label>
              </div>

              {config.aiEnabled && (
                <>
                  {/* AI Provider Selection */}
                  <div className="space-y-4">
                    <h4 className="text-md font-medium text-white">Add AI Models</h4>
                    
                    {/* Provider Dropdown */}
                    <div>
                      <label className="block text-sm font-medium text-gray-200 mb-2">Select Provider</label>
                      <select
                        value={selectedProvider}
                        onChange={(e) => {
                          const provider = availableProviders.find(p => p.name === e.target.value)
                          if (provider) handleProviderSelect(provider)
                        }}
                        className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white"
                      >
                        <option value="">Choose AI Provider</option>
                        {availableProviders.map((provider) => (
                          <option key={provider.id} value={provider.name}>
                            {provider.name}
                          </option>
                        ))}
                      </select>
                    </div>

                    {/* Model Selection */}
                    {selectedProvider && availableModels[selectedProvider] && (
                      <div>
                        <label className="block text-sm font-medium text-gray-200 mb-2">Available Models</label>
                        <div className="max-h-48 overflow-y-auto space-y-2">
                          {availableModels[selectedProvider].map((model) => (
                            <button
                              key={model.id}
                              onClick={() => addModel(selectedProvider, model)}
                              className="w-full text-left px-4 py-3 bg-gray-600 hover:bg-gray-500 text-white rounded-lg text-sm transition-colors border border-gray-500 hover:border-gray-400"
                            >
                              <div className="flex items-center justify-between">
                                <div>
                                  <div className="font-medium">{model.name}</div>
                                  <div className="text-xs text-gray-300 mt-1">
                                    ${model.avgCostPerMillion}/M avg
                                  </div>
                                  {model.keyName && (
                                    <div className="text-xs text-blue-300 mt-1">API Key: {model.keyName}</div>
                                  )}
                                </div>
                                <div className="text-primary text-lg font-bold">+</div>
                              </div>
                            </button>
                          ))}
                        </div>
                      </div>
                    )}

                    {/* Selected Models */}
                    {config.selectedModels.length > 0 && (
                      <div>
                        <label className="block text-sm font-medium text-gray-200 mb-2">Selected Models</label>
                        <div className="space-y-2">
                          {config.selectedModels.map((modelKey) => (
                            <div key={modelKey} className="flex items-center justify-between bg-gray-700/50 rounded-lg p-3">
                              <span className="text-white font-medium">{modelKey}</span>
                              <button
                                onClick={() => removeModel(modelKey)}
                                className="text-red-400 hover:text-red-300"
                              >
                                <Trash2 className="w-4 h-4" />
                              </button>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </div>

                  {/* AI Parameters */}
                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <label className="block text-sm font-medium text-gray-200 mb-2">
                        Temperature ({config.temperature})
                      </label>
                      <input
                        type="range"
                        min="0"
                        max="1"
                        step="0.1"
                        value={config.temperature || 0.7}
                        onChange={(e) => setConfig({ ...config, temperature: parseFloat(e.target.value) })}
                        className="w-full"
                      />
                    </div>

                    <div>
                      <label className="block text-sm font-medium text-gray-200 mb-2">Max Tokens</label>
                      <input
                        type="number"
                        value={config.maxTokens || 2000}
                        onChange={(e) => setConfig({ ...config, maxTokens: parseInt(e.target.value) })}
                        className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white"
                        min="100"
                        max="8000"
                      />
                    </div>
                  </div>
                </>
              )}
            </div>
          )}


          {/* Advanced Tab */}
          {activeTab === 'advanced' && (
            <div className="space-y-6">
              {/* Output Format Section */}
              {node?.type === 'output' && (
                <div className="space-y-4">
                  <h4 className="text-lg font-semibold text-gray-200 border-b border-gray-600 pb-2">Output Configuration</h4>
                  <div>
                    <label className="block text-sm font-medium text-gray-200 mb-3">Output Formats (Multiple Selection)</label>
                    <div className="grid grid-cols-2 gap-3">
                      {[
                        { value: 'text', label: 'Plain Text', icon: 'ðŸ“„', description: 'Simple text format' },
                        { value: 'markdown', label: 'Markdown', icon: 'ðŸ“', description: 'Formatted text with markup' },
                        { value: 'html', label: 'HTML', icon: 'ðŸŒ', description: 'Web-ready format' },
                        { value: 'pdf', label: 'PDF', icon: 'ðŸ“•', description: 'Professional document' },
                        { value: 'epub', label: 'EPUB', icon: 'ðŸ“š', description: 'E-book format' },
                        { value: 'docx', label: 'DOCX', icon: 'ðŸ“„', description: 'Microsoft Word format' }
                      ].map((format) => {
                        const isSelected = (config.outputFormats || []).includes(format.value)
                        return (
                          <div
                            key={format.value}
                            onClick={() => {
                              const currentFormats = config.outputFormats || []
                              const newFormats = isSelected 
                                ? currentFormats.filter(f => f !== format.value)
                                : [...currentFormats, format.value]
                              
                              setConfig({ 
                                ...config, 
                                outputFormats: newFormats,
                                outputFormat: newFormats[0] || 'text' // Keep single format for backward compatibility
                              })
                            }}
                            className={`
                              cursor-pointer rounded-xl p-4 border-2 transition-all duration-300 hover:scale-105
                              ${isSelected 
                                ? 'border-blue-500 bg-blue-500/20 shadow-lg shadow-blue-500/20' 
                                : 'border-gray-600 bg-gray-700/50 hover:border-gray-500'
                              }
                            `}
                          >
                            <div className="flex items-center justify-between mb-2">
                              <span className="text-2xl">{format.icon}</span>
                              {isSelected && (
                                <div className="w-5 h-5 bg-blue-500 rounded-full flex items-center justify-center">
                                  <svg className="w-3 h-3 text-white" fill="currentColor" viewBox="0 0 20 20">
                                    <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                                  </svg>
                                </div>
                              )}
                            </div>
                            <div className="text-sm font-medium text-white">{format.label}</div>
                            <div className="text-xs text-gray-400 mt-1">{format.description}</div>
                          </div>
                        )
                      })}
                    </div>
                    <p className="text-xs text-gray-400 mt-3">
                      Select multiple formats to generate your book in different output types simultaneously
                    </p>
                  </div>

                  <div className="flex items-center justify-between">
                    <div>
                      <label className="block text-sm font-medium text-gray-200">Generate Cover</label>
                      <p className="text-xs text-gray-400">Automatically generate book cover</p>
                    </div>
                    <label className="relative inline-flex items-center cursor-pointer">
                      <input
                        type="checkbox"
                        checked={config.generateCover}
                        onChange={(e) => setConfig({ ...config, generateCover: e.target.checked })}
                        className="sr-only peer"
                      />
                      <div className="w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-primary"></div>
                    </label>
                  </div>
                </div>
              )}

              {/* Customer Input Fields - Only show for Framework flows */}
            </div>
          )}

          {/* Variables Tab */}
          {activeTab === 'variables' && node?.type === 'input' && (
            <div className="space-y-6">
              <div className="bg-purple-900/20 border border-purple-500/30 rounded-lg p-4">
                <div className="flex items-center gap-2 mb-4">
                  <h3 className="text-lg font-semibold text-purple-200">Dynamic Variable Tokens</h3>
                </div>
                <p className="text-sm text-purple-300 mb-4">
                  Click on any variable to add it to your Basic Input and Test Input tabs. Variables already in use are greyed out.
                </p>
                
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  {/* Dynamic Variables from All Flows */}
                  <div className="space-y-3">
                    <h4 className="text-md font-semibold text-purple-200 border-b border-purple-600 pb-1">Available Variables</h4>
                    <div className="space-y-2 text-sm max-h-96 overflow-y-auto">
                      {getAllAvailableVariablesLocal().map((variable, index) => {
                        const isAlreadyUsed = config.inputFields.some(field => 
                          field.variable === variable.variable || field.name === variable.variable
                        )
                        
                        return (
                          <div 
                            key={index}
                            className={`flex justify-between items-center p-2 rounded cursor-pointer transition-all ${
                              isAlreadyUsed 
                                ? 'bg-gray-700/50 text-gray-400 cursor-not-allowed' 
                                : 'bg-purple-800/30 hover:bg-purple-700/50 text-purple-200 hover:text-white'
                            }`}
                            onClick={() => !isAlreadyUsed && addVariableToInput(variable)}
                          >
                            <code className="bg-purple-800/50 px-2 py-1 rounded text-purple-200">
                              {`{${variable.variable}}`}
                            </code>
                            <span className="text-purple-300">{variable.name}</span>
                            {isAlreadyUsed && (
                              <span className="text-xs text-gray-500 ml-2">âœ“ Added</span>
                            )}
                          </div>
                        )
                      })}
                    </div>
                  </div>

                  {/* Currently Used Variables */}
                  <div className="space-y-3">
                    <h4 className="text-md font-semibold text-purple-200 border-b border-purple-600 pb-1">Currently Used Variables</h4>
                    <div className="space-y-2 text-sm max-h-96 overflow-y-auto">
                      {config.inputFields.map((field, index) => (
                        <div key={index} className="flex justify-between items-center p-2 rounded bg-green-800/30 text-green-200">
                          <code className="bg-green-800/50 px-2 py-1 rounded text-green-200">
                            {`{${field.variable}}`}
                          </code>
                          <span className="text-green-300">{field.name}</span>
                          <span className="text-xs text-green-500 ml-2">âœ“ Active</span>
                        </div>
                      ))}
                      {config.inputFields.length === 0 && (
                        <div className="text-center text-gray-400 py-4">
                          No variables added yet. Click on variables from the left to add them.
                        </div>
                      )}
                    </div>
                  </div>
                </div>

                <div className="mt-6 p-4 bg-purple-800/20 rounded-lg">
                  <h4 className="text-md font-semibold text-purple-200 mb-2">Usage Example</h4>
                  <p className="text-sm text-purple-300 mb-2">
                    Use these tokens in your AI prompts like this:
                  </p>
                  <code className="block bg-purple-900/50 p-3 rounded text-purple-200 text-sm">
                    Generate a {'{word_count}'}-word book titled "{'{book_title}'}" for {'{target_audience}'} in {'{tone}'} tone, focusing on {'{topic}'} with {'{chapter_count}'} chapters.
                  </code>
                </div>
              </div>
            </div>
          )}

          {/* Test Input Tab */}
          {activeTab === 'test' && node?.type === 'input' && (
            <div className="space-y-6">
              <div className="bg-blue-900/20 border border-blue-500/30 rounded-lg p-4">
                <div className="flex items-center justify-between mb-2">
                  <div className="flex items-center gap-2">
                    <RefreshCw className="w-5 h-5 text-blue-400" />
                    <h3 className="text-lg font-semibold text-blue-400">Test Input Values</h3>
                  </div>
                  <div className="flex items-center gap-3">
                    <span className="text-sm text-gray-300">Use Custom Input:</span>
                    <label className="relative inline-flex items-center cursor-pointer">
                      <input
                        type="checkbox"
                        checked={testInputEnabled}
                        onChange={(e) => setTestInputEnabled(e.target.checked)}
                        className="sr-only peer"
                      />
                      <div className="w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-500"></div>
                    </label>
                    <button
                      onClick={syncBasicInputWithTestInput}
                      className="bg-gray-600 hover:bg-gray-700 text-white px-3 py-1 rounded-lg text-sm transition-all duration-300 flex items-center space-x-1"
                      title="Sync Test Input with Basic Input"
                    >
                      <RefreshCw className="w-3 h-3" />
                      <span>Sync</span>
                    </button>
                  </div>
                </div>
                <p className="text-sm text-gray-300">
                  {testInputEnabled 
                    ? "Custom input values will override default values when workflow runs."
                    : "Using default values from Basic Info tab and hardcoded defaults."
                  }
                </p>
                
                {/* Input Coverage Indicator */}
                {config.inputFields && config.inputFields.length > 0 && (
                  <div className="mt-3 p-3 bg-gray-800/50 rounded-lg border border-gray-600/50">
                    <div className="flex items-center justify-between mb-2">
                      <span className="text-sm font-medium text-gray-300">Input Field Coverage</span>
                      <span className="text-xs text-gray-400">
                        {(() => {
                          const validation = validateInputCoverage()
                          return `${validation.coverage.basic}/${validation.coverage.total} Basic â€¢ ${validation.coverage.test}/${validation.coverage.total} Test`
                        })()}
                      </span>
                    </div>
                    <div className="flex space-x-2">
                      <div className="flex-1 bg-gray-700 rounded-full h-2">
                        <div 
                          className="bg-blue-500 h-2 rounded-full transition-all duration-300"
                          style={{width: `${(() => {
                            const validation = validateInputCoverage()
                            return (validation.coverage.basic / validation.coverage.total) * 100
                          })()}%`}}
                        ></div>
                      </div>
                      <div className="flex-1 bg-gray-700 rounded-full h-2">
                        <div 
                          className="bg-green-500 h-2 rounded-full transition-all duration-300"
                          style={{width: `${(() => {
                            const validation = validateInputCoverage()
                            return (validation.coverage.test / validation.coverage.total) * 100
                          })()}%`}}
                        ></div>
                      </div>
                    </div>
                    <div className="flex justify-between mt-1">
                      <span className="text-xs text-blue-400">Basic Input</span>
                      <span className="text-xs text-green-400">Test Input</span>
                    </div>
                  </div>
                )}
              </div>

              {/* Test Scenario Dropdown */}
              {testInputEnabled && config.inputFields?.length > 0 && (
                <div className="space-y-4">
                  <h4 className="text-md font-semibold text-gray-200 border-b border-gray-600 pb-2">
                    Quick Test Scenarios
                  </h4>
                  <div>
                    <label className="block text-sm font-medium text-gray-200 mb-2">
                      Select a test scenario to auto-fill all fields:
                    </label>
                    <select
                      onChange={(e) => {
                        if (e.target.value) {
                          // Use Framework flow test scenarios if available
                          const scenarios = config.testScenarios && config.testScenarios.length > 0 
                            ? config.testScenarios 
                            : generateTestScenarios(config.inputFields)
                          const selectedScenario = scenarios.find(s => s.name === e.target.value)
                          if (selectedScenario) {
                            setTestInputValues(selectedScenario.data)
                            toast.success(`Loaded "${selectedScenario.name}" test data`)
                          }
                        }
                      }}
                      className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white"
                    >
                      <option value="">Choose a test scenario...</option>
                      {(config.testScenarios && config.testScenarios.length > 0 
                        ? config.testScenarios 
                        : generateTestScenarios(config.inputFields)).map((scenario, index) => (
                        <option key={index} value={scenario.name}>
                          {scenario.name}
                        </option>
                      ))}
                    </select>
                    <p className="text-xs text-gray-400 mt-1">
                      Select a scenario to automatically fill all input fields with realistic test data
                    </p>
                  </div>
                </div>
              )}

              {/* Dynamic Test Input Fields Based on Node Input Fields - Only show for Framework flows */}
              {config.inputFields && Array.isArray(config.inputFields) && config.inputFields.length > 0 && (
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <h4 className="text-md font-semibold text-gray-200 border-b border-gray-600 pb-2 flex-1">
                    {getGenreDisplayName()} Input Fields ({config.inputFields.length} fields)
                  </h4>
                  <div className="ml-4 flex items-center space-x-2">
                    <div className={`w-3 h-3 rounded-full ${getGenreColor()}`}></div>
                    <span className="text-xs text-gray-400 font-medium">{getGenreDisplayName()}</span>
                  </div>
                </div>
                <div className={`grid grid-cols-2 gap-4 ${!testInputEnabled ? 'opacity-50 pointer-events-none' : ''}`}>
                  {config.inputFields.map((field, index) => {
                    // Handle conditional field display
                    if (field.conditional) {
                      const condition = field.conditional
                      if (condition.includes('book_size === "custom"')) {
                        const bookSizeValue = testInputValues.book_size || testInputValues[field.variable] || ''
                        if (bookSizeValue !== 'custom') {
                          return null // Don't render this field
                        }
                      }
                    }
                    
                    return (
                    <div key={field.id || index} className={field.fullWidth ? 'col-span-2' : ''}>
                      <label className="block text-sm font-medium text-gray-200 mb-2">
                        {field.name} {field.required && <span className="text-red-400">*</span>}
                      </label>
                      
                      {field.type === 'text' && (
                        <input
                          type="text"
                          value={testInputValues[field.variable] || testInputValues[field.name] || ''}
                          onChange={(e) => setTestInputValues({
                            ...testInputValues, 
                            [field.variable]: e.target.value,
                            [field.name]: e.target.value
                          })}
                          placeholder={getProfessionalPlaceholder(field)}
                          className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white"
                        />
                      )}
                      
                      {field.type === 'textarea' && (
                        <textarea
                          value={testInputValues[field.variable] || testInputValues[field.name] || ''}
                          onChange={(e) => setTestInputValues({
                            ...testInputValues, 
                            [field.variable]: e.target.value,
                            [field.name]: e.target.value
                          })}
                          placeholder={getProfessionalPlaceholder(field)}
                          rows={field.rows || 3}
                          className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white"
                        />
                      )}
                      
                      {field.type === 'select' && (
                        <select
                          value={testInputValues[field.variable] || testInputValues[field.name] || ''}
                          onChange={(e) => {
                            const value = field.multiple ? 
                              Array.from(e.target.selectedOptions, option => option.value) : 
                              e.target.value
                            setTestInputValues({
                              ...testInputValues, 
                              [field.variable]: value,
                              [field.name]: value
                            })
                          }}
                          multiple={field.multiple}
                          className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white"
                        >
                          <option value="">ðŸŽ¯ Choose Your {field.name || 'Option'}</option>
                          {getFieldOptions(field)?.map((option, optIndex) => (
                            <option key={optIndex} value={typeof option === 'string' ? option : option.value}>
                              {typeof option === 'string' ? option : (option.label || option.name || option.value || option)}
                            </option>
                          ))}
                        </select>
                      )}
                      
                      {field.type === 'number' && (
                        <input
                          type="number"
                          value={testInputValues[field.name] || testInputValues[field.variable] || ''}
                          onChange={(e) => setTestInputValues({
                            ...testInputValues, 
                            [field.name]: e.target.value,
                            [field.variable]: e.target.value
                          })}
                          placeholder={getProfessionalPlaceholder(field)}
                          min={field.min}
                          max={field.max}
                          className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white"
                        />
                      )}
                      
                      {field.type === 'checkbox' && (
                        <label className="flex items-center space-x-2">
                          <input
                            type="checkbox"
                            checked={testInputValues[field.name] || testInputValues[field.variable] || false}
                            onChange={(e) => setTestInputValues({
                              ...testInputValues, 
                              [field.name]: e.target.checked,
                              [field.variable]: e.target.checked
                            })}
                            className="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500"
                          />
                          <span className="text-gray-200">{field.name}</span>
                        </label>
                      )}
                    </div>
                    )
                  })}
                </div>
              </div>
              )}


              {/* Advanced Features */}
              <div className="space-y-4">
                <h4 className="text-md font-semibold text-gray-200 border-b border-gray-600 pb-2">Advanced Features</h4>
                <div className={`grid grid-cols-2 gap-4 ${!testInputEnabled ? 'opacity-50 pointer-events-none' : ''}`}>
                  <div className="flex items-center justify-between">
                    <div>
                      <label className="block text-sm font-medium text-gray-200">Include Images</label>
                      <p className="text-xs text-gray-400">Add images to the content</p>
                    </div>
                    <label className="relative inline-flex items-center cursor-pointer">
                      <input
                        type="checkbox"
                        checked={testInputValues.includeImages}
                        onChange={(e) => setTestInputValues({...testInputValues, includeImages: e.target.checked})}
                        className="sr-only peer"
                      />
                      <div className="w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-primary"></div>
                    </label>
                  </div>
                  <div className="flex items-center justify-between">
                    <div>
                      <label className="block text-sm font-medium text-gray-200">Voice Cloning</label>
                      <p className="text-xs text-gray-400">Enable voice cloning features</p>
                    </div>
                    <label className="relative inline-flex items-center cursor-pointer">
                      <input
                        type="checkbox"
                        checked={testInputValues.voiceCloningEnabled}
                        onChange={(e) => setTestInputValues({...testInputValues, voiceCloningEnabled: e.target.checked})}
                        className="sr-only peer"
                      />
                      <div className="w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-primary"></div>
                    </label>
                  </div>
                  <div className="flex items-center justify-between">
                    <div>
                      <label className="block text-sm font-medium text-gray-200">Fact Checking</label>
                      <p className="text-xs text-gray-400">Enable fact checking</p>
                    </div>
                    <label className="relative inline-flex items-center cursor-pointer">
                      <input
                        type="checkbox"
                        checked={testInputValues.factCheckingEnabled}
                        onChange={(e) => setTestInputValues({...testInputValues, factCheckingEnabled: e.target.checked})}
                        className="sr-only peer"
                      />
                      <div className="w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-primary"></div>
                    </label>
                  </div>
                  <div className="flex items-center justify-between">
                    <div>
                      <label className="block text-sm font-medium text-gray-200">Interactive Content</label>
                      <p className="text-xs text-gray-400">Include interactive elements</p>
                    </div>
                    <label className="relative inline-flex items-center cursor-pointer">
                      <input
                        type="checkbox"
                        checked={testInputValues.interactiveContent}
                        onChange={(e) => setTestInputValues({...testInputValues, interactiveContent: e.target.checked})}
                        className="sr-only peer"
                      />
                      <div className="w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-primary"></div>
                    </label>
                  </div>
                </div>
              </div>

              {/* Author Details */}
              <div className="space-y-4">
                <h4 className="text-md font-semibold text-gray-200 border-b border-gray-600 pb-2">Author Details</h4>
                <div className={`grid grid-cols-2 gap-4 ${!testInputEnabled ? 'opacity-50 pointer-events-none' : ''}`}>
                  <div>
                    <label className="block text-sm font-medium text-gray-200 mb-2">Profession</label>
                    <input
                      type="text"
                      value={testInputValues.profession}
                      onChange={(e) => setTestInputValues({...testInputValues, profession: e.target.value})}
                      className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-200 mb-2">Experience Level</label>
                    <select
                      value={testInputValues.experienceLevel}
                      onChange={(e) => setTestInputValues({...testInputValues, experienceLevel: e.target.value})}
                      className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white"
                    >
                      <option value="Beginner">Beginner</option>
                      <option value="Intermediate">Intermediate</option>
                      <option value="Advanced">Advanced</option>
                      <option value="Expert">Expert</option>
                    </select>
                  </div>
                  <div className="col-span-2">
                    <label className="block text-sm font-medium text-gray-200 mb-2">Content Focus</label>
                    <textarea
                      value={testInputValues.contentFocus}
                      onChange={(e) => setTestInputValues({...testInputValues, contentFocus: e.target.value})}
                      rows={3}
                      className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white"
                    />
                  </div>
                  <div className="col-span-2">
                    <label className="block text-sm font-medium text-gray-200 mb-2">Custom Instructions</label>
                    <textarea
                      value={testInputValues.customInstructions}
                      onChange={(e) => setTestInputValues({...testInputValues, customInstructions: e.target.value})}
                      rows={3}
                      className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white"
                    />
                  </div>
                </div>
              </div>



              {/* Save Instructions */}
              <div className="space-y-4">
                <div className="bg-green-900/20 border border-green-500/30 rounded-lg p-4">
                  <div className="flex items-center gap-2 mb-2">
                    <CheckCircle className="w-5 h-5 text-green-400" />
                    <h4 className="text-md font-semibold text-green-400">Save & Run</h4>
                  </div>
                  <p className="text-sm text-gray-300">
                    Click "Save Configuration" to save these custom input values to the node. Then run the workflow normally - it will use your custom values instead of the defaults.
                  </p>
                </div>
              </div>
            </div>
          )}
        </div>

        {/* Footer */}
        <div className="flex justify-end gap-3 mt-8 pt-6 border-t border-gray-700">
          <button
            onClick={onClose}
            className="px-6 py-2 text-gray-300 hover:text-white transition-colors"
          >
            Cancel
          </button>
          
          {/* Show different buttons for new nodes vs existing nodes */}
          {node?.isNewNode ? (
            <>
              <button
                onClick={handleSave}
                className="flex items-center gap-2 px-6 py-2 bg-gray-600 hover:bg-gray-500 text-white rounded-lg transition-colors"
              >
                <Save className="w-4 h-4" />
                Save to Flow Only
              </button>
              <button
                onClick={saveToPalette}
                className="flex items-center gap-2 px-6 py-2 bg-emerald-600 hover:bg-emerald-700 text-white rounded-lg transition-colors"
              >
                <Plus className="w-4 h-4" />
                Save to Palette
              </button>
            </>
          ) : (
            <button
              onClick={handleSave}
              className="flex items-center gap-2 px-6 py-2 bg-primary hover:bg-primary/90 text-white rounded-lg transition-colors"
            >
              <Save className="w-4 h-4" />
              Save Configuration
            </button>
          )}
        </div>
      </div>
    </div>
  )
}

export default FlowNodeModal