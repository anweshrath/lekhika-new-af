import React, { useState, useEffect, useRef } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { 
  X, 
  Sparkles, 
  Loader2, 
  CheckCircle, 
  AlertTriangle, 
  Rocket,
  Download,
  Eye,
  Zap,
  Brain,
  Clock,
  TrendingUp,
  DollarSign,
  FileText,
  PlayCircle,
  PauseCircle,
  StopCircle,
  Layers,
  Cpu,
  Network,
  Activity,
  Target,
  Shield,
  Star,
  ArrowRight,
  RefreshCw,
  Edit3
} from 'lucide-react'
import Confetti from 'react-confetti'
import { useWindowSize } from 'react-use'
import toast from 'react-hot-toast'
import UltraButton from './UltraButton'
import AIThinkingModal from './AIThinkingModal'
import UserBookEditorModal from './UserBookEditorModal'
import { sanitizeForExport } from '../utils/sanitize'
import { useUserAuth } from '../contexts/UserAuthContext'
import dbService from '../services/database'
import { supabase } from '../lib/supabase'

// üëë MASTER AGGREGATOR & SANITIZER v2: This is the new source of truth.
// It is resilient to the AI's tendency to dump unstructured JSON and metadata.
const addChapterToCollection = (chapters, chapter, fallbackTitle = '') => {
  if (!chapter) return;
  const content = chapter.content || chapter.text || chapter.body || chapter.chapterContent || chapter.cleanedContent || '';
  if (typeof content !== 'string' || content.trim().length < 50) return;

  let title = chapter.title || chapter.heading || chapter.name || fallbackTitle;
  if (!title || /chapter\s*\d+/i.test(title)) {
    const headerMatch = content.match(/^(?:#+\s*)(.*)/m);
    if (headerMatch && headerMatch[1]) {
      title = headerMatch[1].trim();
    }
  }

  chapters.push({
    number: chapters.length + 1,
    title: title || `Chapter ${chapters.length + 1}`,
    content: content
  });
};

const getAggregatedContent = (executionData) => {
  if (!executionData) return { title: 'Untitled', chapters: [], html: '', markdown: '', formats: {} };

  const normalizedExecutionData = (() => {
    if (executionData.executionData && typeof executionData.executionData === 'object') {
      return {
        ...executionData,
        ...executionData.executionData,
        nodeResults: {
          ...(executionData.executionData.nodeResults || {}),
          ...(executionData.nodeResults || {})
        },
        aiOutputs: [
          ...(executionData.executionData.aiOutputs || []),
          ...(executionData.aiOutputs || [])
        ],
        allFormats: {
          ...(executionData.executionData.allFormats || {}),
          ...(executionData.allFormats || {})
        }
      };
    }
    return executionData;
  })();

  const nodeResults = normalizedExecutionData?.nodeResults || {};
  const aiOutputs = normalizedExecutionData?.aiOutputs || [];
  let title = normalizedExecutionData?.userInput?.book_title || normalizedExecutionData?.metadata?.title || 'Untitled Book';
  let foreword = '';
  let introduction = '';
  const chapters = [];

  const allOutputs = [
    ...Object.values(nodeResults).map(r => r.content),
    ...aiOutputs.map(o => o.content)
  ].filter(Boolean);

  for (const rawContent of allOutputs) {
    if (typeof rawContent !== 'string') continue;

    let contentToParse = rawContent;

    // STAGE 1: Attempt to parse as JSON to extract narrative directly.
    try {
      const jsonMatch = contentToParse.match(/(\{[\s\S]*\})/);
      if (jsonMatch && jsonMatch[1]) {
        const parsed = JSON.parse(jsonMatch[1]);
        
        if (parsed.bookTitle && title === 'Untitled Book') title = parsed.bookTitle;
        if (parsed.openingContent?.foreword) foreword = parsed.openingContent.foreword;
        if (parsed.openingContent?.introduction) introduction = parsed.openingContent.introduction;

        // Check for actual chapter content
        if (parsed.chapter1Content?.sections) {
            const narrative = parsed.chapter1Content.sections.map(sec => `<h3>${sec.sectionTitle || ''}</h3>\n<p>${sec.content || ''}</p>`).join('\n\n');
            if(narrative) chapters.push({ number: 1, title: 'Chapter 1', content: narrative });
        }
        // This is a common pattern for single-chapter generation
        else if (parsed.content) {
             chapters.push({ number: chapters.length + 1, title: `Chapter ${chapters.length + 1}`, content: parsed.content });
        }
        
        console.log("‚úÖ Master Aggregator: Extracted content via JSON parsing.");
        // If we found content this way, we can often skip the regex part for this output
        if (chapters.length > 0) continue; 
      }
    } catch (e) {
      console.warn("Master Aggregator: JSON parsing failed, falling back to regex.", e);
    }
    
    // STAGE 2: Aggressive regex-based cleanup for non-JSON or malformed content.
    // Foreword extraction
    const forewordMatch = contentToParse.match(/^(?:##\s*Foreword)([\s\S]*?)(?=\n##\s*|\n#\s*|$)/im);
    if (forewordMatch && !foreword) foreword = forewordMatch[1].trim();
    
    // Introduction extraction
    const introMatch = contentToParse.match(/^(?:##\s*Introduction)([\s\S]*?)(?=\n##\s*|\n#\s*|$)/im);
    if (introMatch && !introduction) introduction = introMatch[1].trim();

    // Chapter extraction
    const chapterMatches = contentToParse.matchAll(/^(?:##\s*Chapter\s*(\d+).*?|##\s*)(.*?)\n([\s\S]*?)(?=\n##\s*|\n#\s*|$)/gim);
    for (const match of chapterMatches) {
        let chapterNum = match[1] ? parseInt(match[1], 10) : chapters.length + 1;
        let chapterTitle = match[2]?.trim().replace(/\*/g, '') || `Chapter ${chapterNum}`;
        let chapterContent = match[3]?.trim();

        // Critically, remove the JSON metadata from the chapter content itself
        chapterContent = chapterContent.replace(/\{[\s\S]*\}/gm, '');

        if (chapterContent && chapterContent.length > 100) { 
            if (!chapters.some(c => c.number === chapterNum)) {
                chapters.push({ number: chapterNum, title: chapterTitle, content: chapterContent });
            }
        }
    }
  }

  Object.values(nodeResults).forEach(result => {
    if (!result) return;
    const nodeLabel = result.nodeName || '';

    if (Array.isArray(result.metadata?.chapters)) {
      result.metadata.chapters.forEach(chapter => addChapterToCollection(chapters, chapter, nodeLabel));
    }

    if (Array.isArray(result.chapters)) {
      result.chapters.forEach(chapter => addChapterToCollection(chapters, chapter, nodeLabel));
    }

    if (Array.isArray(result.compiledData?.sections)) {
      result.compiledData.sections.forEach(section => addChapterToCollection(chapters, section, nodeLabel));
    }
  });

  chapters.sort((a, b) => a.number - b.number);
  const uniqueChapters = [];
  const seenSignatures = new Set();
  chapters.forEach((chapter) => {
    const signature = (chapter.content || '').trim().slice(0, 200);
    if (!signature) return;
    if (seenSignatures.has(signature)) return;
    seenSignatures.add(signature);
    uniqueChapters.push({
      ...chapter,
      id: `chapter-${uniqueChapters.length + 1}`,
      number: uniqueChapters.length + 1
    });
  });

  // Assemble the final HTML
  let fullHtml = `<h1>${title}</h1>`;
  if (foreword) fullHtml += `<h2>Foreword</h2><div>${foreword}</div>`;
  if (introduction) fullHtml += `<h2>Introduction</h2><div>${introduction}</div>`;
  
  if (uniqueChapters.length > 0) {
    fullHtml += '<h2>Table of Contents</h2><ul>';
    uniqueChapters.forEach(chap => {
      fullHtml += `<li><a href="#chapter-${chap.number}">${chap.title}</a></li>`;
    });
    fullHtml += '</ul><hr />';
    
    uniqueChapters.forEach(chap => {
      fullHtml += `<div id="chapter-${chap.number}"><h2>${chap.title}</h2><div>${chap.content}</div></div>`;
    });
  }

  // Assemble Markdown
  let fullMarkdown = `# ${title}\n\n`;
  if (foreword) fullMarkdown += `## Foreword\n\n${foreword}\n\n`;
  if (introduction) fullMarkdown += `## Introduction\n\n${introduction}\n\n`;
  uniqueChapters.forEach(chap => {
    fullMarkdown += `## ${chap.title}\n\n${chap.content}\n\n`;
  });
  
  return {
    title,
    foreword,
    introduction,
    chapters: uniqueChapters,
    html: fullHtml,
    markdown: fullMarkdown,
    formats: {
      html: fullHtml,
      md: fullMarkdown,
      txt: fullMarkdown.replace(/<[^>]*>?/gm, '')
    }
  };
};


const getNodeIcon = (node) => {
  const role = node.data?.role?.toLowerCase() || '';
  if (role.includes('writer')) return FileText;
  if (role.includes('architect') || role.includes('outliner')) return Brain;
  if (role.includes('editor')) return Edit3;
  if (role.includes('image') || role.includes('ecover')) return Zap;
  return Cpu;
};

const UserExecutionModal = ({
  isOpen,
  onClose,
  executionData,
  onForceStop,
  onRestart,
  pollingIssue = false
}) => {
  const [isResuming, setIsResuming] = useState(false)
  const { user } = useUserAuth()
  
  const { width, height } = useWindowSize()
  const [showConfetti, setShowConfetti] = useState(false)
  const [particles, setParticles] = useState([])
  const [progressHistory, setProgressHistory] = useState([])
  const [isAnimating, setIsAnimating] = useState(false)
  const [showAIThinkingModal, setShowAIThinkingModal] = useState(false)
  const [stopAttempted, setStopAttempted] = useState(false)
  const [stopTimeout, setStopTimeout] = useState(null)
  const [showBookEditor, setShowBookEditor] = useState(false)
  const [bookEditorData, setBookEditorData] = useState(null)
  const [isPublishing, setIsPublishing] = useState(false);
  const [publishedBookId, setPublishedBookId] = useState(null);
  
  const progressRef = useRef(0)
  const prevProgressRef = useRef(0)
  const prevNodeRef = useRef(null)
  
  // SURGICAL FIX: Add total accumulation state variables
  const [totalTokens, setTotalTokens] = useState(0)
  const [totalWords, setTotalWords] = useState(0)
  const [totalCost, setTotalCost] = useState(0)
  const [liveLog, setLiveLog] = useState([]);
  const logContainerRef = useRef(null);

  useEffect(() => {
    if (executionData?.status === 'running' && executionData?.currentNode && executionData.currentNode !== prevNodeRef.current) {
      const newNodeName = executionData.nodes?.find(n => n.id === executionData.currentNode)?.data?.label || executionData.currentNode;
      setLiveLog(prev => [...prev, `[${new Date().toLocaleTimeString()}] ‚ö° Starting: ${newNodeName}`]);
      prevNodeRef.current = executionData.currentNode;
    }
    if (executionData?.status === 'completed' || executionData?.status === 'failed') {
      if (!liveLog.some(l => l.includes('Execution finished'))) {
        setLiveLog(prev => [...prev, `[${new Date().toLocaleTimeString()}] ‚úÖ Execution finished with status: ${executionData.status.toUpperCase()}`]);
      }
    }
  }, [executionData?.status, executionData?.currentNode, executionData?.nodes, liveLog]);

  useEffect(() => {
    if (logContainerRef.current) {
      logContainerRef.current.scrollTop = logContainerRef.current.scrollHeight;
    }
  }, [liveLog]);
  
  // Get available formats from executionData
  const getAvailableFormats = () => {
    // SURGICAL FIX: Check multiple locations for formats
    
    // Check nodeResults for output node with formats
    if (executionData?.nodeResults) {
      const outputNode = Object.entries(executionData.nodeResults).find(([id, result]) => 
        result?.metadata?.allFormats || result?.type === 'final_output'
      )
      
      if (outputNode && outputNode[1].metadata?.allFormats) {
        return Object.keys(outputNode[1].metadata.allFormats).filter(f => outputNode[1].metadata.allFormats[f] != null)
      }
    }
    
    // Fallback to executionData.allFormats
    if (executionData?.allFormats) {
      return Object.keys(executionData.allFormats)
    }
    
    // Final fallback: If we have aiOutputs, offer basic text/html formats
    if (executionData?.aiOutputs && executionData.aiOutputs.length > 0) {
      return ['txt', 'html']
    }
    
    return []
  }

  // Resume failed execution from checkpoint
  const handleResumeExecution = async () => {
    if (!executionData?.id && !executionData?.executionId) {
      toast.error('Execution ID not found')
      return
    }
    
    // Allow resume on ANY failed execution - no resumable flag required
    
    if (!executionData?.nodes || !executionData?.edges) {
      toast.error('Workflow data (nodes/edges) not available for resume')
      return
    }
    
    setIsResuming(true)

    try {
      const executionId = executionData.id || executionData.executionId
      
      let nodes = executionData.nodes;
      let edges = executionData.edges;

      // SURGICAL FIX: If nodes/edges are missing, fetch them from the engine blueprint
      if (!nodes || !edges || nodes.length === 0 || edges.length === 0) {
        toast.loading('Workflow blueprint missing, fetching from database...');
        console.log(' M.I.A. - fetching blueprint for engine ID:', executionData.userEngineId || executionData.engineId);
        const blueprint = await dbService.getEngineBlueprint(executionData.userEngineId || executionData.engineId);
        if (blueprint) {
          nodes = blueprint.nodes;
          edges = blueprint.edges;
          toast.dismiss();
          toast.success('Blueprint recovered!');
        } else {
          throw new Error('Could not recover engine blueprint.');
        }
      }

      const resumeApiUrl = `${import.meta.env.VITE_SUPABASE_URL}/functions/v1/engines-api/${executionData.userEngineId || executionData.engineId}/resume`
      
      const response = await fetch(resumeApiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${import.meta.env.VITE_SUPABASE_ANON_KEY}`,
          'X-API-Key': executionData.apiKey || ''
        },
        body: JSON.stringify({
          executionId: executionId,
          engineId: executionData.engineId,
          userEngineId: executionData.userEngineId,
          userId: executionData.userId,
          nodes: nodes, // Use the potentially recovered nodes
          edges: edges  // Use the potentially recovered edges
        })
      })
      
      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Failed to resume execution')
      }
      
      const result = await response.json()
      toast.success('üîÑ Execution resumed successfully! Continuing from checkpoint...')
      
      // The execution will continue and poll updates will show progress
      // No need to close modal - let it continue showing progress
      
    } catch (error) {
      console.error('‚ùå Resume failed:', error)
      toast.error(`Failed to resume: ${error.message}`)
    } finally {
      setIsResuming(false)
    }
  }

  // Save book to My Books database
  const saveToMyBooks = async (formattedOutputs, formats) => {
    try {
      if (!user?.id) {
        toast.error('User not authenticated')
        return
      }

      // Get book details from execution data
      const bookTitle = executionData?.userInput?.book_title || executionData?.userInput?.story_title || 'Generated Book'
      const bookType = executionData?.userInput?.type || 'ebook'
      const niche = executionData?.userInput?.genre || executionData?.userInput?.niche || 'general'
      const targetAudience = executionData?.userInput?.target_audience || 'general'
      const tone = executionData?.userInput?.tone || 'professional'
      
      // Calculate total word count from all content
      let totalWords = 0
      if (executionData?.nodeResults) {
        Object.values(executionData.nodeResults).forEach(result => {
          if (result?.content && typeof result.content === 'string') {
            totalWords += result.content.split(/\s+/).length
          }
        })
      }

      // Get token count from execution data
      const tokens = executionData?.tokens || executionData?.metadata?.totalTokens || 0

      // Determine status based on execution state
      let status = 'draft'
      if (executionData?.status === 'completed') {
        status = 'completed'
      } else if (executionData?.status === 'failed' || executionData?.error) {
        status = 'generating' // Partial/in-progress
      } else if (executionData?.status === 'running') {
        status = 'generating'
      }

      // Prepare book data for database
      const bookData = {
        user_id: user.id,
        title: bookTitle,
        type: bookType,
        niche: niche,
        target_audience: targetAudience,
        tone: tone,
        status: status,
        content: formattedOutputs,
        metadata: {
          formats: formats,
          execution_id: executionData?.id,
          tokens_used: tokens,
          word_count: totalWords,
          chapter_count: executionData?.userInput?.chapter_count || '1',
          created_from: 'execution_download',
          original_input: executionData?.userInput
        },
        ai_service: executionData?.aiService || executionData?.provider || 'openai', // Use detected service or default
        word_count: totalWords
      }

      // Save to database
      const savedBook = await dbService.createBook(bookData)
      
      toast.success(`üìö Book "${bookTitle}" saved to My Books!`)
      console.log('‚úÖ Book saved to My Books:', savedBook.id)

    } catch (error) {
      console.error('‚ùå Failed to save book to My Books:', error)
      toast.error('Failed to save book to library')
    }
  }

  // üëë NEW: Professional Publishing Flow
  const publishAndDownloadBook = async () => {
    setIsPublishing(true);
    const toastId = toast.loading('Connecting to the Master Publisher...');
    try {
      if (!user?.id) throw new Error('User not authenticated.');

      // Step 1: Create a placeholder book entry to get an ID
      toast.update(toastId, 'üìö Reserving space in the Lekhika library...');
      const bookDetails = getAggregatedContent(executionData);
      const placeholderBook = {
        user_id: user.id,
        title: bookDetails.title || 'Untitled Book',
        status: 'processing', // This is a new status
        content: null,
        metadata: { rawExecutionData: executionData } // Pass the full execution data
      };
      const newBook = await dbService.createBook(placeholderBook);
      const newBookId = newBook.id;
      if (!newBookId) throw new Error('Failed to create a book record.');

      setPublishedBookId(newBookId);
      toast.update(toastId, '‚úÖ Reserved! Engaging Master Publisher...');

      // Step 2: Invoke the backend function to do the heavy lifting
      const { error } = await supabase.functions.invoke('process-and-save-book', {
        body: { bookId: newBookId },
      });
      if (error) throw new Error(`Master Publisher rejected the task: ${error.message}`);
      
      toast.update(toastId, 'üöÄ Master Publisher is formatting all files...');

      // Step 3: Poll for completion
      await pollForPublishedBook(newBookId, toastId);

    } catch (error) {
      console.error('Error during professional publishing:', error);
      toast.error(`Publishing failed: ${error.message}`, { id: toastId });
      setIsPublishing(false);
    }
  };

  const pollForPublishedBook = async (bookId, toastId) => {
    let attempts = 0;
    const maxAttempts = 30; // 5 minutes max polling
    const interval = 10000; // 10 seconds

    const poll = async (resolve, reject) => {
      if (attempts >= maxAttempts) {
        return reject(new Error('Publishing timed out. Your book is safe but took too long to format.'));
      }
      
      const book = await dbService.getBook(bookId);
      if (book && book.status === 'completed' && book.format_urls) {
        return resolve(book);
      } else {
        attempts++;
        toast.update(toastId, `[${attempts}/${maxAttempts}] üìö Publisher is working... Status: ${book.status || 'processing'}`);
        setTimeout(() => poll(resolve, reject), interval);
      }
    };

    return new Promise(poll)
      .then((book) => {
        toast.success('‚úÖ All professional formats are ready! Downloading now...', { id: toastId, duration: 5000 });
        // Trigger download of all available formats
        Object.entries(book.format_urls).forEach(([format, url]) => {
          if(url) window.open(url, '_blank');
        });
        setIsPublishing(false);
      })
      .catch((error) => {
        toast.error(error.message, { id: toastId, duration: 5000 });
        setIsPublishing(false);
      });
  };


  // Confetti on completion
  useEffect(() => {
    if (executionData?.status === 'completed') {
      setShowConfetti(true)
      setTimeout(() => setShowConfetti(false), 8000)
    }
  }, [executionData?.status])

  // Generate floating particles during AI thinking
  useEffect(() => {
    if (executionData?.status === 'running' && executionData?.aiThinking) {
      const interval = setInterval(() => {
        setParticles(prev => [
          ...prev.slice(-15),
          {
            id: Date.now() + Math.random(),
            x: Math.random() * 100,
            y: Math.random() * 100,
            size: Math.random() * 4 + 2,
            opacity: Math.random() * 0.8 + 0.2
          }
        ])
      }, 150)
      return () => clearInterval(interval)
    }
  }, [executionData?.status, executionData?.aiThinking])

  // Track progress changes for smooth animations
  useEffect(() => {
    if (executionData?.progress !== undefined) {
      const currentProgress = executionData.progress
      const prevProgress = prevProgressRef.current
      
      if (currentProgress > prevProgress) {
        setProgressHistory(prev => [...prev.slice(-10), { 
          progress: currentProgress, 
          timestamp: Date.now(),
          nodeName: executionData.currentNode
        }])
        setIsAnimating(true)
        setTimeout(() => setIsAnimating(false), 800)
      }
      
      prevProgressRef.current = currentProgress
      progressRef.current = currentProgress
    }
  }, [executionData?.progress, executionData?.currentNode])
  
  // SURGICAL FIX: Accumulate totals from execution data
  useEffect(() => {
    if (executionData) {
      if (executionData.tokens) {
        setTotalTokens(prev => prev + (executionData.tokens || 0))
      }
      if (executionData.words) {
        setTotalWords(prev => prev + (executionData.words || 0))
      }
      if (executionData.cost) {
        setTotalCost(prev => prev + (executionData.cost || 0))
      }
    }
  }, [executionData?.tokens, executionData?.words, executionData?.cost])

  const getStatusColor = () => {
    switch (executionData?.status) {
      case 'completed': return '#10b981'
      case 'failed': return '#ef4444'
      case 'running': return '#3b82f6'
      case 'cancelling': return '#f59e0b'
      case 'cancelled': return '#6b7280'
      default: return '#6b7280'
    }
  }

  const getStatusIcon = () => {
    switch (executionData?.status) {
      case 'completed': return CheckCircle
      case 'failed': return AlertTriangle
      case 'running': return Loader2
      case 'cancelling': return Loader2
      case 'cancelled': return StopCircle
      default: return PlayCircle
    }
  }

  const StatusIcon = getStatusIcon()
  const progress = executionData?.progress ?? 0
  const status = executionData?.status || 'unknown'
  const nodeName = executionData?.nodeName || executionData?.currentNode || 'Processing...'

  // Calculate progress segments for visual feedback
  const progressSegments = [
    { name: 'Initialize', range: [0, 20], color: '#3b82f6', description: 'Setting up workflow and validating inputs' },
    { name: 'AI Processing', range: [20, 60], color: '#8b5cf6', description: 'AI is analyzing and generating content' },
    { name: 'Content Generation', range: [60, 85], color: '#ec4899', description: 'Creating final content output' },
    { name: 'Finalizing', range: [85, 100], color: '#10b981', description: 'Processing and validating results' }
  ]

  const currentSegment = progressSegments.find(seg => 
    progress >= seg.range[0] && progress < seg.range[1]
  ) || progressSegments[3]

  // Calculate chapter progress - ENHANCED to use real chapter info from worker
  const nodeResults = executionData?.nodeResults || {}
  const completedNodeIds = Object.keys(nodeResults)
  
  // CRITICAL: Use actual chapter info from worker if available
  let currentChapter = 1
  let totalChapters = 1
  let chapterProgress = progress || 0
  
  // Check if we have real chapter information from the worker
  const chapterInfo = executionData?.chapterInfo
  if (chapterInfo && chapterInfo.totalChapters > 0) {
    currentChapter = chapterInfo.currentChapter || 1
    totalChapters = chapterInfo.totalChapters
    chapterProgress = Math.round((currentChapter / totalChapters) * 100)
    console.log('üìä Using REAL chapter progress:', { currentChapter, totalChapters, chapterProgress })
  } else {
    // SURGICAL FIX: Fallback to a more robust progress calculation.
    const completedNodes = completedNodeIds.length
    currentChapter = completedNodes + 1
    
    // PRIORITY 1: Use the actual number of nodes in the workflow as the total.
    if (executionData?.nodes && executionData.nodes.length > 0) {
      totalChapters = executionData.nodes.length;
    } else {
      // PRIORITY 2: Fallback to user input, but guarantee total is never less than current.
      const userChapterCount = parseInt(executionData?.userInput?.chapter_count || executionData?.userInput?.chapterCount || '1', 10);
      totalChapters = Math.max(userChapterCount, currentChapter);
    }
    
    chapterProgress = totalChapters > 0 ? Math.round(((completedNodes) / totalChapters) * 100) : 0
    
    // SURGICAL FIX: Only log when values actually change to prevent infinite spam
    const progressKey = `${totalChapters}-${currentChapter}-${chapterProgress}`
    if (!window.lastProgressKey || window.lastProgressKey !== progressKey) {
      console.log('üìä Using FALLBACK progress:', { totalChapters, currentChapter, chapterProgress, completedNodes })
      window.lastProgressKey = progressKey
    }
  }
  
  // For backward compatibility, keep totalNodes for existing references
  const totalNodes = totalChapters

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          key="execution-modal-overlay"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 bg-black/80 backdrop-blur-xl z-50 flex items-center justify-center p-4"
          onClick={onClose}
        >
          {/* Confetti for completion */}
          {showConfetti && (
            <Confetti
              width={width}
              height={height}
              recycle={false}
              numberOfPieces={800}
              gravity={0.2}
              colors={['#3b82f6', '#8b5cf6', '#ec4899', '#10b981', '#f59e0b']}
            />
          )}

          <motion.div
            initial={{ opacity: 0, scale: 0.8, y: 100 }}
            animate={{ opacity: 1, scale: 1, y: 0 }}
            exit={{ opacity: 0, scale: 0.8, y: 100 }}
            transition={{ 
              duration: 0.6, 
              ease: [0.4, 0, 0.2, 1],
              type: "spring",
              stiffness: 100
            }}
            className="relative w-full max-w-8xl h-[95vh] overflow-hidden flex flex-col"
            onClick={(e) => e.stopPropagation()}
          >
            {/* Main Card with Ultra Glassmorphism */}
            <div
              className="relative overflow-hidden rounded-3xl flex-1 flex flex-col"
              style={{
                background: 'rgba(15, 15, 25, 0.98)',
                backdropFilter: 'blur(60px)',
                border: '1px solid rgba(255, 255, 255, 0.15)',
                boxShadow: `
                  0 25px 80px rgba(0, 0, 0, 0.6),
                  0 0 0 1px rgba(255, 255, 255, 0.05),
                  inset 0 1px 0 rgba(255, 255, 255, 0.1)
                `
              }}
            >
              {/* Thin execution rail - visual only */}
              <motion.div
                className="absolute left-0 top-0 h-1"
                style={{ background: `linear-gradient(90deg, ${getStatusColor()}, ${currentSegment.color})` }}
                initial={{ width: 0 }}
                animate={{ width: `${Math.min(Math.max(progress || 0, 0), 100)}%` }}
                transition={{ duration: 0.6, ease: 'easeOut' }}
              />
              {/* Polling warning banner */}
              {pollingIssue && (
                <div className="absolute left-0 right-0 top-0 z-20">
                  <div className="mx-6 mt-3 rounded-xl px-4 py-2 text-sm font-medium flex items-center gap-2"
                       style={{ background: 'rgba(245, 158, 11, 0.15)', border: '1px solid rgba(245, 158, 11, 0.4)', color: '#fbbf24' }}>
                    ‚ö†Ô∏è Temporary database polling issue detected. Checking worker directly‚Ä¶
                  </div>
                </div>
              )}

              {/* Animated Background Gradient */}
              <motion.div
                className="absolute inset-0 opacity-30"
                style={{
                  background: `radial-gradient(circle at 30% 20%, ${getStatusColor()}40, transparent 50%),
                              radial-gradient(circle at 70% 80%, ${currentSegment.color}30, transparent 50%),
                              radial-gradient(circle at 50% 50%, rgba(139, 92, 246, 0.2), transparent 70%)`,
                }}
                animate={{
                  opacity: [0.2, 0.4, 0.2]
                }}
                transition={{
                  duration: 4,
                  repeat: Infinity,
                  ease: 'easeInOut'
                }}
              />


              <div className="relative z-10 h-full flex flex-col">
                {/* Scrollable Content Area */}
                <div className="flex-1 overflow-y-auto overflow-x-hidden px-4 py-2">

                {/* Header with Compact Progress Circle */}
                <div className="flex items-center justify-between p-8 border-b border-white/10">
                  <div className="flex items-center gap-6">
                    {/* Compact Progress Circle */}
                    <div className="relative w-16 h-16">
                      <svg className="w-16 h-16 transform -rotate-90">
                        <circle
                          cx="32"
                          cy="32"
                          r="28"
                          stroke="rgba(255, 255, 255, 0.1)"
                          strokeWidth="4"
                          fill="none"
                        />
                        <motion.circle
                          cx="32"
                          cy="32"
                          r="28"
                          stroke={getStatusColor()}
                          strokeWidth="4"
                          fill="none"
                          strokeLinecap="round"
                          initial={{ strokeDashoffset: 176 }}
                          animate={{ 
                            strokeDashoffset: 176 - (176 * progress) / 100,
                          }}
                          style={{
                            strokeDasharray: 176,
                            filter: `drop-shadow(0 0 10px ${getStatusColor()})`,
                          }}
                          transition={{ duration: 1, ease: 'easeOut' }}
                        />
                      </svg>
                      <div className="absolute inset-0 flex items-center justify-center">
                        <StatusIcon 
                          className={`w-6 h-6 ${executionData?.status === 'running' ? 'animate-spin' : ''}`}
                          style={{ color: getStatusColor() }}
                        />
                      </div>
                    </div>
                    
                    <div>
                      <motion.h3 
                        className="text-2xl font-bold text-white mb-2"
                        initial={{ opacity: 0, x: -20 }}
                        animate={{ opacity: 1, x: 0 }}
                        transition={{ delay: 0.2 }}
                      >
                        {executionData?.status === 'completed' ? '‚ú® Content Generated!' :
                         executionData?.status === 'failed' ? '‚ùå Generation Failed' :
                         executionData?.status === 'cancelling' ? '‚èπÔ∏è Stopping Execution...' :
                         executionData?.status === 'cancelled' ? '‚èπÔ∏è Execution Cancelled' :
                         'üöÄ Generating Content...'}
                      </motion.h3>
                      <motion.p 
                        className="text-lg text-gray-300"
                        initial={{ opacity: 0, x: -20 }}
                        animate={{ opacity: 1, x: 0 }}
                        transition={{ delay: 0.3 }}
                      >
                        {executionData?.currentNode || 'Initializing...'}
                      </motion.p>
                      
                      {/* ERROR DETAILS - Show when failed */}
                      {executionData?.status === 'failed' && executionData?.error && (
                        <motion.div
                          className="mt-4 p-4 rounded-xl border-2"
                          initial={{ opacity: 0, y: 10 }}
                          animate={{ opacity: 1, y: 0 }}
                          transition={{ delay: 0.4 }}
                          style={{
                            background: 'rgba(239, 68, 68, 0.1)',
                            borderColor: 'rgba(239, 68, 68, 0.4)'
                          }}
                        >
                          <div className="flex items-start gap-3">
                            <AlertTriangle className="w-5 h-5 text-red-400 flex-shrink-0 mt-0.5" />
                            <div className="flex-1">
                              <div className="font-semibold text-red-300 mb-2">Execution Failed</div>
                              <div className="text-sm text-red-200 whitespace-pre-wrap break-words">
                                {typeof executionData.error === 'string' 
                                  ? executionData.error 
                                  : executionData.error?.message || JSON.stringify(executionData.error, null, 2)}
                              </div>
                              {executionData.error?.stack && (
                                <details className="mt-2">
                                  <summary className="text-xs text-red-300 cursor-pointer hover:text-red-200">Show technical details</summary>
                                  <pre className="mt-2 text-xs text-red-400 overflow-auto max-h-40 p-2 bg-black/20 rounded">
                                    {executionData.error.stack}
                                  </pre>
                                </details>
                              )}
                            </div>
                          </div>
                        </motion.div>
                      )}
                      
                      {/* Chapter Progress Indicator */}
                      {totalNodes > 1 && (
                        <motion.div 
                          className="flex items-center gap-2 mt-2"
                          initial={{ opacity: 0, y: 10 }}
                          animate={{ opacity: 1, y: 0 }}
                          transition={{ delay: 0.4 }}
                        >
                          <div className="text-sm font-medium text-gray-400">
                            {chapterInfo ? `Chapter ${currentChapter}/${totalChapters}` : `Step ${currentChapter}/${totalChapters}`}
                          </div>
                          <div className="flex-1 w-20 h-2 bg-gray-700/50 rounded-full overflow-hidden">
                            <motion.div
                              className="h-full rounded-full"
                              style={{
                                background: `linear-gradient(90deg, ${getStatusColor()}, ${currentSegment.color})`,
                                boxShadow: `0 0 10px ${getStatusColor()}40`
                              }}
                              initial={{ width: 0 }}
                              animate={{ width: `${chapterProgress}%` }}
                              transition={{ duration: 0.8, ease: 'easeOut' }}
                            />
                          </div>
                          <div className="text-xs text-gray-500 font-mono">
                            {chapterProgress}%
                          </div>
                        </motion.div>
                      )}
                      
                      {/* Progress Segment Indicator with Phase Description */}
                      <motion.div 
                        className="flex items-center gap-2 mt-2"
                        initial={{ opacity: 0, y: 10 }}
                        animate={{ opacity: 1, y: 0 }}
                        transition={{ delay: 0.4 }}
                      >
                        <div 
                          className="w-3 h-3 rounded-full"
                          style={{ background: currentSegment.color }}
                        />
                        <div className="flex flex-col">
                          <span 
                            className="text-sm font-medium"
                            style={{ color: currentSegment.color }}
                          >
                            {currentSegment.name}
                          </span>
                          <span className="text-xs text-gray-400">
                            {currentSegment.description}
                          </span>
                        </div>
                      </motion.div>
                    </div>
                  </div>
                  
                  <motion.button
                    whileHover={{ scale: 1.1, rotate: 90 }}
                    whileTap={{ scale: 0.9 }}
                    onClick={onClose}
                    className="p-3 rounded-2xl hover:bg-white/10 transition-all duration-300 text-gray-400 hover:text-white"
                  >
                    <X className="w-6 h-6" />
                  </motion.button>
                </div>

                {/* MAGICAL DETAILED PROGRESS SECTION */}
                {(executionData?.status === 'running' || executionData?.status === 'failed' || executionData?.error) && (
                  <div className="px-8 py-4">
                    <div 
                      className="rounded-3xl p-8 relative overflow-hidden"
                      style={{
                        background: 'linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(147, 51, 234, 0.1) 50%, rgba(236, 72, 153, 0.1) 100%)',
                        border: '2px solid rgba(147, 51, 234, 0.3)',
                        backdropFilter: 'blur(20px)',
                        boxShadow: '0 20px 40px rgba(147, 51, 234, 0.2)'
                      }}
                    >
                      {/* Magical Background Effects */}
                      <div className="absolute inset-0 opacity-20">
                        {Array.from({ length: 6 }).map((_, i) => (
                          <motion.div
                            key={`magical-particle-${i}`}
                            className="absolute w-1 h-1 rounded-full"
                            style={{
                              left: `${15 + i * 15}%`,
                              top: `${20 + i * 10}%`,
                              background: `hsl(${240 + i * 60}, 70%, 60%)`,
                            }}
                            animate={{
                              y: [-20, -40],
                              opacity: [0, 1, 0],
                              scale: [0.5, 1, 0.5]
                            }}
                            transition={{ 
                              duration: 4 + Math.random() * 2,
                              repeat: Infinity,
                              delay: i * 0.3
                            }}
                          />
                        ))}
                      </div>
                      
                      <div className="relative z-10">
                        <div className="flex items-center justify-between mb-6">
                          <motion.h4 
                            className="text-white font-bold text-xl flex items-center gap-3"
                            initial={{ opacity: 0, x: -20 }}
                            animate={{ opacity: 1, x: 0 }}
                            transition={{ delay: 0.2 }}
                          >
                            <motion.span
                              animate={{ rotate: [0, 360] }}
                              transition={{ duration: 3, repeat: Infinity, ease: "linear" }}
                              className="text-2xl"
                            >
                              üìä
                            </motion.span>
                            AI Processing Pipeline
                          </motion.h4>
                          <motion.div 
                            className="text-purple-300 text-lg font-mono px-4 py-2 rounded-xl"
                            style={{
                              background: 'rgba(147, 51, 234, 0.2)',
                              border: '1px solid rgba(147, 51, 234, 0.3)'
                            }}
                            initial={{ opacity: 0, scale: 0 }}
                            animate={{ opacity: 1, scale: 1 }}
                            transition={{ delay: 0.4 }}
                          >
                            {executionData?.progress || 0}% Complete
                          </motion.div>
                        </div>
                        
                        {/* Enhanced Dynamic Node Timeline */}
                        <div className="space-y-4">
                          {/* Simple skeletons when running with no nodeResults yet */}
                          {executionData?.status === 'running' && (!executionData?.nodeResults || Object.keys(executionData.nodeResults).length === 0) && (
                            <div className="space-y-3">
                              {[1,2,3].map(i => (
                                <div key={`skeleton-${i}`} className="w-full h-14 rounded-xl" style={{ background: 'rgba(255,255,255,0.06)', border: '1px solid rgba(255,255,255,0.08)' }} />
                              ))}
                            </div>
                          )}
                          {(() => {
                            // SURGICAL FIX: Use processingSteps if available, fallback to nodeResults
                            const processingSteps = executionData?.processingSteps || []
                            const nodeResults = executionData?.nodeResults || {}
                            const currentNode = executionData?.currentNode || ''
                            
                            // Create dynamic pipeline based on actual nodes
                            const pipeline = []
                            let stepNumber = 1 // Track sequential step numbers
                            
                            // PRIORITY: Use processingSteps if available (preserves all execution history)
                            if (processingSteps.length > 0) {
                              processingSteps.forEach((step) => {
                                pipeline.push({
                                  id: step.id || `step-${stepNumber}`,
                                  name: `Step ${stepNumber}: ${step.name}`,
                                  stepNumber: stepNumber++,
                                  status: step.status || 'completed',
                                  icon: step.status === 'completed' ? '‚úÖ' : step.status === 'running' ? 'üîÑ' : '‚è≥',
                                  color: step.status === 'completed' ? '#10b981' : step.status === 'running' ? '#8b5cf6' : '#6b7280',
                                  progress: step.progress || 100,
                                  tokens: step.tokens,
                                  duration: step.duration
                                })
                              })
                            } else {
                              // FALLBACK: Use nodeResults if processingSteps not available
                              completedNodeIds.forEach((nodeId) => {
                                const result = nodeResults[nodeId]
                                const nodeName = (result?.nodeName || nodeId).replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())
                                pipeline.push({
                                  id: nodeId,
                                  name: `Step ${stepNumber}: ${nodeName}`,
                                  stepNumber: stepNumber++,
                                  status: 'completed',
                                  icon: '‚úÖ',
                                  color: '#10b981',
                                  progress: 100
                                })
                              })
                            }
                            
                            // Add current running node if not already in pipeline and processingSteps didn't include it
                            const alreadyInPipeline = pipeline.some(p => p.id === currentNode || p.name.includes(currentNode))
                            if (currentNode && !alreadyInPipeline) {
                              const nodeName = currentNode.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())
                              // Add chapter info if available
                              const chapterInfo = executionData?.chapterInfo
                              const displayName = chapterInfo 
                                ? `Step ${stepNumber}: ${nodeName} (Chapter ${chapterInfo.current}/${chapterInfo.total})`
                                : `Step ${stepNumber}: ${nodeName}`
                              
                              pipeline.push({
                                id: currentNode,
                                name: displayName,
                                stepNumber: stepNumber++,
                                status: 'running',
                                icon: 'üîÑ',
                                color: '#8b5cf6',
                                progress: executionData?.progress || 0,
                                chapterInfo: chapterInfo
                              })
                            }
                            
                            // Add placeholder for next steps (minimum 4 total steps)
                            const targetTotalSteps = Math.max(4, stepNumber)
                            const remainingSteps = Math.max(0, targetTotalSteps - pipeline.length)
                            for (let i = 0; i < remainingSteps; i++) {
                              pipeline.push({
                                id: `pending-${i}`,
                                name: `Step ${stepNumber + i}`,
                                stepNumber: stepNumber + i,
                                status: 'pending',
                                icon: '‚è≥',
                                color: '#6b7280',
                                progress: 0
                              })
                            }
                            
                            return pipeline
                          })().map((node, index) => (
                            <motion.div
                              key={node.id || `node-${index}`}
                              initial={{ opacity: 0, x: -30 }}
                              animate={{ opacity: 1, x: 0 }}
                              transition={{ delay: 0.1 * index }}
                              className="relative"
                            >
                              <div 
                                className={`flex items-center gap-6 p-6 rounded-2xl transition-all duration-500 border-2 ${
                                  node.status === 'completed' 
                                    ? 'border-green-400/50 bg-green-500/10' 
                                    : node.status === 'running'
                                    ? 'border-purple-400/50 bg-purple-500/10'
                                    : 'border-gray-600/30 bg-gray-700/20'
                                }`}
                                style={{
                                  boxShadow: node.status === 'running' 
                                    ? `0 0 30px ${node.color}40` 
                                    : '0 4px 20px rgba(0, 0, 0, 0.1)'
                                }}
                              >
                                {/* Magical Node Icon */}
                                <motion.div
                                  className="relative"
                                  animate={node.status === 'running' ? {
                                    scale: [1, 1.2, 1],
                                    rotate: [0, 5, -5, 0]
                                  } : {}}
                                  transition={{ 
                                    duration: 2, 
                                    repeat: node.status === 'running' ? Infinity : 0,
                                    ease: 'easeInOut'
                                  }}
                                >
                                  <div className="text-4xl">{node.icon}</div>
                                  {node.status === 'running' && (
                                    <motion.div
                                      animate={{
                                        scale: [1, 1.5, 1],
                                        opacity: [0.5, 1, 0.5]
                                      }}
                                      transition={{
                                        duration: 1.5,
                                        repeat: Infinity
                                      }}
                                      className="absolute inset-0 rounded-full blur-md"
                                      style={{ background: node.color }}
                                    />
                                  )}
                                </motion.div>
                                
                                <div className="flex-1">
                                  <div className="flex items-center gap-3 mb-2">
                                    <motion.div 
                                      className="text-white font-bold text-lg"
                                      style={{ color: node.status === 'running' ? node.color : '#ffffff' }}
                                    >
                                      {node.name}
                                    </motion.div>
                                    {node.status === 'running' && node.progress !== undefined && (
                                      <div className="text-sm font-mono text-purple-300 bg-purple-500/20 px-2 py-1 rounded">
                                        {node.progress}%
                                      </div>
                                    )}
                                  </div>
                                  <motion.div 
                                    className="text-gray-300 text-sm flex items-center gap-2"
                                    initial={{ opacity: 0 }}
                                    animate={{ opacity: 1 }}
                                    transition={{ delay: 0.2 * index }}
                                  >
                                    {node.status === 'completed' ? (
                                      <>
                                        <motion.span
                                          initial={{ scale: 0 }}
                                          animate={{ scale: 1 }}
                                          transition={{ delay: 0.5 }}
                                        >
                                          ‚úÖ
                                        </motion.span>
                                        <span>Completed</span>
                                      </>
                                    ) : node.status === 'running' ? (
                                      <>
                                        <motion.span
                                          animate={{ rotate: 360 }}
                                          transition={{ duration: 2, repeat: Infinity, ease: "linear" }}
                                        >
                                          üîÑ
                                        </motion.span>
                                        <span>Processing...</span>
                                      </>
                                    ) : (
                                      <>
                                        <span>‚è≥</span>
                                        <span>Waiting</span>
                                      </>
                                    )}
                                  </motion.div>

                                  {/* Progress bar for running nodes */}
                                  {node.status === 'running' && node.progress !== undefined && (
                                    <div className="mt-3 w-full bg-gray-700/50 rounded-full h-2 overflow-hidden">
                                      <motion.div
                                        className="h-full rounded-full"
                                        style={{
                                          background: `linear-gradient(90deg, ${node.color}, ${node.color}80)`,
                                          boxShadow: `0 0 10px ${node.color}40`
                                        }}
                                        initial={{ width: 0 }}
                                        animate={{ width: `${node.progress}%` }}
                                        transition={{ duration: 0.8, ease: 'easeOut' }}
                                      />
                                    </div>
                                  )}
                                </div>
                                
                                {node.status === 'running' && (
                                  <motion.div
                                    animate={{ rotate: 360 }}
                                    transition={{ duration: 2, repeat: Infinity, ease: "linear" }}
                                    className="p-3 rounded-full"
                                    style={{ background: `${node.color}20` }}
                                  >
                                    <Cpu className="w-6 h-6" style={{ color: node.color }} />
                                  </motion.div>
                                )}
                              </div>
                            </motion.div>
                          ))}
                        </div>
                      </div>
                    </div>
                  </div>
                )}
                
                {/* Live Log Terminal */}
                <div className="px-8 py-4">
                  <div ref={logContainerRef} className="h-48 bg-black/50 rounded-2xl p-4 font-mono text-xs text-green-400 overflow-y-auto border border-white/10 scrollbar-thin scrollbar-thumb-gray-700 scrollbar-track-gray-800">
                    <p className="text-green-300 font-bold mb-2">~ Lekhika AI Live Terminal ~</p>
                    {liveLog.map((log, i) => (
                      <motion.p key={i} initial={{ opacity: 0 }} animate={{ opacity: 1 }}>{`> ${log}`}</motion.p>
                    ))}
                  </div>
                </div>

                {/* Dynamic Progress Bar with Node Names */}
                {(executionData?.status === 'running' || executionData?.status === 'failed' || executionData?.error) && (
                  <div className="px-8 py-4">
                    <div className="bg-gray-800/50 backdrop-blur-sm rounded-2xl p-4 border border-gray-700/50">
                      <div className="flex items-center justify-between mb-3">
                        <h4 className="text-white font-semibold">Current Process</h4>
                        <div className="text-gray-300 text-sm font-mono">
                          {executionData?.progress || 0}%
                        </div>
                      </div>
                      
                      {/* Progress Bar */}
                      <div className="w-full bg-gray-700/50 rounded-full h-3 mb-3 overflow-hidden">
                        <motion.div
                          className="h-full rounded-full"
                          style={{
                            background: `linear-gradient(90deg, ${getStatusColor()}, ${currentSegment.color})`,
                            boxShadow: `0 0 20px ${getStatusColor()}40`
                          }}
                          initial={{ width: 0 }}
                          animate={{ width: `${executionData?.progress || 0}%` }}
                          transition={{ duration: 0.8, ease: 'easeOut' }}
                        />
                      </div>
                      
                      {/* Current Node */}
                      <div className="flex items-center gap-2">
                        <motion.div
                          animate={{ rotate: 360 }}
                          transition={{ duration: 2, repeat: Infinity, ease: "linear" }}
                        >
                          <Cpu className="w-4 h-4 text-blue-400" />
                        </motion.div>
                        <span className="text-gray-200 text-sm">
                          {executionData?.currentNode || 'Initializing...'}
                        </span>
                      </div>
                    </div>
                  </div>
                )}

                {/* Header with Progress Info */}
                <div className="flex items-center justify-between p-6 border-b border-white/10">
                  <div className="flex items-center gap-4">
                    {/* SEXY AS FUCK Progress Circle */}
                    <div className="relative w-20 h-20">
                      {/* Outer Glow Ring */}
                      <motion.div
                        className="absolute inset-0 rounded-full blur-xl"
                        style={{
                          background: `radial-gradient(circle, ${getStatusColor()}60, transparent 70%)`,
                        }}
                        animate={{
                          scale: [1, 1.2, 1],
                          opacity: [0.4, 0.8, 0.4]
                        }}
                        transition={{
                          duration: 2,
                          repeat: Infinity
                        }}
                      />
                      
                      <svg className="w-20 h-20 transform -rotate-90 relative z-10">
                        <defs>
                          <linearGradient id="sexyProgressGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" stopColor={getStatusColor()} />
                            <stop offset="50%" stopColor={currentSegment.color} />
                            <stop offset="100%" stopColor={getStatusColor()} />
                          </linearGradient>
                        </defs>
                        
                        {/* Background Circle */}
                        <circle
                          cx="40"
                          cy="40"
                          r="32"
                          stroke="rgba(255, 255, 255, 0.15)"
                          strokeWidth="6"
                          fill="none"
                        />
                        
                        {/* Sexy Progress Circle */}
                        <motion.circle
                          cx="40"
                          cy="40"
                          r="32"
                          stroke="url(#sexyProgressGradient)"
                          strokeWidth="6"
                          fill="none"
                          strokeLinecap="round"
                          initial={{ strokeDashoffset: 201 }}
                          animate={{ 
                            strokeDashoffset: 201 - (201 * progress) / 100,
                          }}
                          style={{
                            strokeDasharray: 201,
                            filter: `drop-shadow(0 0 15px ${getStatusColor()}) drop-shadow(0 0 30px ${getStatusColor()}40)`,
                          }}
                          transition={{ duration: 1, ease: 'easeOut' }}
                        />
                      </svg>
                      
                      {/* Center Content */}
                      <div className="absolute inset-0 flex flex-col items-center justify-center">
                        <motion.div
                          key={`progress-${progress}-${executionData?.status}`}
                          initial={{ scale: 1.3, opacity: 0 }}
                          animate={{ scale: 1, opacity: 1 }}
                          transition={{ duration: 0.5, ease: 'easeOut' }}
                          className="text-lg font-black text-white"
                          style={{
                            textShadow: `0 0 10px ${getStatusColor()}`,
                            backgroundImage: `linear-gradient(135deg, ${getStatusColor()}, ${currentSegment.color})`,
                            backgroundClip: 'text',
                            WebkitBackgroundClip: 'text',
                            WebkitTextFillColor: 'transparent'
                          }}
                        >
                          {Math.round(progress)}%
                        </motion.div>
                        {executionData?.status === 'running' && (
                          <motion.div
                            animate={{ rotate: 360 }}
                            transition={{ duration: 2, repeat: Infinity, ease: "linear" }}
                            className="text-xs"
                          >
                            ‚ö°
                          </motion.div>
                        )}
                      </div>
                    </div>
                    
                    <div>
                      <motion.h3 
                        className="text-xl font-bold text-white mb-1"
                        initial={{ opacity: 0, x: -20 }}
                        animate={{ opacity: 1, x: 0 }}
                        transition={{ delay: 0.2 }}
                      >
                        {executionData?.status === 'completed' ? '‚ú® Content Generated!' :
                         executionData?.status === 'failed' ? '‚ùå Generation Failed' :
                         executionData?.status === 'cancelling' ? '‚èπÔ∏è Stopping...' :
                         executionData?.status === 'cancelled' ? '‚èπÔ∏è Cancelled' :
                         'üöÄ Generating Content...'}
                      </motion.h3>
                      <motion.p 
                        className="text-sm text-gray-300"
                        initial={{ opacity: 0, x: -20 }}
                        animate={{ opacity: 1, x: 0 }}
                        transition={{ delay: 0.3 }}
                      >
                        {executionData?.currentNode || 'Initializing...'}
                      </motion.p>
                      
                      {/* Chapter Progress Indicator */}
                      {totalNodes > 1 && (
                        <motion.div 
                          className="flex items-center gap-2 mt-1"
                          initial={{ opacity: 0, y: 10 }}
                          animate={{ opacity: 1, y: 0 }}
                          transition={{ delay: 0.4 }}
                        >
                          <div className="text-xs font-medium text-gray-400">
                            {chapterInfo ? `Chapter ${currentChapter}/${totalChapters}` : `Step ${currentChapter}/${totalChapters}`}
                          </div>
                        </motion.div>
                      )}
                    </div>
                  </div>
                  
                  <motion.button
                    whileHover={{ scale: 1.1, rotate: 90 }}
                    whileTap={{ scale: 0.9 }}
                    onClick={onClose}
                    className="p-3 rounded-2xl hover:bg-white/10 transition-all duration-300 text-gray-400 hover:text-white"
                  >
                    <X className="w-6 h-6" />
                  </motion.button>
                </div>

                {/* Comprehensive Stats Section */}
                <div className="px-8 pb-8 flex-shrink-0">
                  <motion.div 
                    className="space-y-6"
                    initial={{ opacity: 0, y: 20 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ delay: 0.3 }}
                  >
                    {/* Main Stats Grid */}
                    <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                      {[
                        { 
                          icon: Zap, 
                          label: 'Tokens', 
                          value: totalTokens.toLocaleString(), 
                          color: '#f59e0b',
                          animated: executionData?.status === 'running',
                          subtitle: 'Total AI Tokens Used'
                        },
                        { 
                          icon: FileText, 
                          label: 'Words', 
                          value: totalWords.toLocaleString(), 
                          color: '#8b5cf6',
                          animated: executionData?.status === 'running',
                          subtitle: 'Total Content Generated'
                        },
                        { 
                          icon: Clock, 
                          label: 'Time', 
                          value: `${Math.round(executionData?.duration || 0)}s`, 
                          color: '#ec4899',
                          animated: executionData?.status === 'running',
                          subtitle: 'Processing Time'
                        },
                        { 
                          icon: Network, 
                          label: 'Node', 
                          value: executionData?.currentNode ? executionData.currentNode.split(' ')[0] : 'Init', 
                          color: '#10b981',
                          animated: executionData?.status === 'running',
                          subtitle: 'Current Step'
                        }
                      ].map((stat, index) => (
                      <motion.div
                        key={stat.label}
                        whileHover={{ scale: 1.05, y: -5 }}
                        className="p-4 rounded-2xl relative overflow-hidden group cursor-pointer"
                        style={{ 
                          background: 'rgba(255, 255, 255, 0.05)',
                          border: `1px solid rgba(255, 255, 255, 0.1)`,
                          backdropFilter: 'blur(20px)'
                        }}
                        initial={{ opacity: 0, y: 20 }}
                        animate={{ opacity: 1, y: 0 }}
                        transition={{ delay: 0.4 + index * 0.1 }}
                      >
                        {/* Hover Glow */}
                        <motion.div
                          className="absolute inset-0 rounded-2xl"
                          style={{
                            background: `linear-gradient(135deg, ${stat.color}20, transparent)`,
                            opacity: 0
                          }}
                          whileHover={{ opacity: 1 }}
                          transition={{ duration: 0.3 }}
                        />
                        
                        <div className="relative z-10 text-center">
                          <motion.div
                            whileHover={{ rotate: 360 }}
                            transition={{ duration: 0.6 }}
                          >
                            <stat.icon 
                              className="w-6 h-6 mx-auto mb-2" 
                              style={{ color: stat.color }}
                            />
                          </motion.div>
                          <motion.div 
                            className="text-2xl font-bold text-white mb-1"
                            animate={stat.animated ? { scale: [1, 1.1, 1] } : {}}
                            transition={{ duration: 0.5, repeat: Infinity, repeatDelay: 2 }}
                          >
                            {stat.value}
                          </motion.div>
                          <div className="text-sm text-gray-400 font-medium">
                            {stat.label}
                          </div>
                          <div className="text-xs text-gray-500 mt-1">
                            {stat.subtitle}
                          </div>
                        </div>
                      </motion.div>
                    ))}
                    </div>

                    {/* REMOVED: Worthless Generated Content Preview - Use AI Thinking Modal instead */}

                    {/* REMOVED: Fake Execution Timeline - Real progress shown in AI Thinking Modal */}
                  </motion.div>
                </div>

                {/* Error Display */}
                {executionData?.error && (
                  <motion.div
                    initial={{ opacity: 0, y: 30 }}
                    animate={{ opacity: 1, y: 0 }}
                    className="px-8 pb-6"
                  >
                    <div 
                      className="p-6 rounded-2xl relative overflow-hidden"
                      style={{
                        background: 'rgba(239, 68, 68, 0.1)',
                        border: '1px solid rgba(239, 68, 68, 0.3)',
                        backdropFilter: 'blur(20px)'
                      }}
                    >
                      <div className="flex items-start gap-4">
                        <motion.div
                          animate={{ 
                            scale: [1, 1.2, 1],
                            rotate: [0, -10, 10, 0]
                          }}
                          transition={{ 
                            duration: 1.5, 
                            repeat: Infinity 
                          }}
                        >
                          <AlertTriangle className="w-7 h-7 text-red-400" />
                        </motion.div>
                        <div className="flex-1">
                          <div className="text-lg font-bold text-red-400 mb-2">
                            Error occurred
                          </div>
                          <div className="text-gray-200">
                            {executionData.error}
                          </div>
                        </div>
                      </div>
                    </div>
                  </motion.div>
                )}

                </div>
                
                {/* Ultra Action Buttons - Fixed Position */}
                <div className="px-8 pb-8 flex gap-4 justify-center flex-shrink-0">
                  {/* AI Thinking Button - Always visible when there's execution data */}
                  {executionData && (
                    <motion.div 
                      whileHover={{ scale: 1.05 }} 
                      whileTap={{ scale: 0.95 }}
                      initial={{ opacity: 0, y: 20 }}
                      animate={{ opacity: 1, y: 0 }}
                      transition={{ delay: 0.3 }}
                    >
                      <UltraButton
                        onClick={() => setShowAIThinkingModal(true)}
                        variant="primary"
                        icon={Brain}
                        className="px-6 py-4 text-lg font-bold"
                        style={{
                          background: 'linear-gradient(135deg, #8b5cf6, #7c3aed)',
                          border: 'none',
                          boxShadow: '0 8px 32px rgba(139, 92, 246, 0.3)'
                        }}
                      >
                        View AI Thinking
                      </UltraButton>
                    </motion.div>
                  )}
                  
                  {/* Download Partial Book Button */}
                  {(executionData?.status === 'cancelled' || executionData?.status === 'failed' || executionData?.status === 'completed') && executionData?.nodeResults && Object.keys(executionData.nodeResults).length > 0 && (
                    <motion.div 
                      whileHover={{ scale: 1.05 }} 
                      whileTap={{ scale: 0.95 }}
                      initial={{ opacity: 0, y: 20 }}
                      animate={{ opacity: 1, y: 0 }}
                      transition={{ delay: 0.4 }}
                    >
                      <UltraButton
                        onClick={() => publishAndDownloadBook()}
                        variant="secondary"
                        icon={isPublishing ? Loader2 : Download}
                        disabled={isPublishing}
                        className="px-6 py-4 text-lg font-bold"
                        style={{
                          background: 'linear-gradient(135deg, #10b981, #059669)',
                          border: 'none',
                          boxShadow: '0 8px 32px rgba(16, 185, 129, 0.3)'
                        }}
                      >
                        {isPublishing ? 'Publishing...' : 'Publish & Download'}
                      </UltraButton>
                    </motion.div>
                  )}
                  
                  {/* Partial Download - Show for running/failed with content */}
                  {executionData?.status === 'running' && executionData?.nodeResults && Object.keys(executionData.nodeResults).length > 0 && (
                    <motion.div 
                      whileHover={{ scale: 1.05 }} 
                      whileTap={{ scale: 0.95 }}
                      initial={{ opacity: 0, y: 20 }}
                      animate={{ opacity: 1, y: 0 }}
                      transition={{ delay: 0.35 }}
                    >
                      <UltraButton
                        onClick={() => publishAndDownloadBook()}
                        variant="secondary"
                        icon={isPublishing ? Loader2 : Download}
                        disabled={isPublishing}
                        className="px-6 py-4 text-lg font-bold"
                        style={{
                          background: 'linear-gradient(135deg, #f59e0b, #d97706)',
                          border: 'none',
                          boxShadow: '0 8px 32px rgba(245, 158, 11, 0.3)'
                        }}
                      >
                        {isPublishing ? 'Publishing...' : 'Publish & Download'}
                      </UltraButton>
                    </motion.div>
                  )}
                  
                  {/* Stop Button - Show for running, failed, or error states */}
                  {(executionData?.status === 'running' || executionData?.status === 'failed' || executionData?.error) && (
                    <motion.div 
                      whileHover={{ scale: 1.05 }} 
                      whileTap={{ scale: 0.95 }}
                      initial={{ opacity: 0, x: -20 }}
                      animate={{ opacity: 1, x: 0 }}
                      transition={{ delay: 0.4 }}
                    >
                      <UltraButton
                        onClick={onForceStop}
                        variant="secondary"
                        icon={StopCircle}
                        className="px-6 py-4 text-lg font-bold"
                        disabled={executionData?.status === 'cancelling'}
                        style={{
                          background: 'linear-gradient(135deg, #ef4444, #dc2626)',
                          border: 'none',
                          boxShadow: '0 8px 32px rgba(239, 68, 68, 0.3)'
                        }}
                      >
                        {executionData?.status === 'cancelling' ? 'Stopping...' : 'Stop'}
                      </UltraButton>
                    </motion.div>
                  )}
                  
                  {/* Resume Button - Show for ANY failed executions */}
                  {(executionData?.status === 'failed' || executionData?.error) && (
                    <motion.div 
                      whileHover={{ scale: 1.05 }} 
                      whileTap={{ scale: 0.95 }}
                      initial={{ opacity: 0, x: 20 }}
                      animate={{ opacity: 1, x: 0 }}
                      transition={{ delay: 0.45 }}
                    >
                      <UltraButton
                        onClick={handleResumeExecution}
                        disabled={isResuming}
                        variant="primary"
                        icon={PlayCircle}
                        className="px-6 py-4 text-lg font-bold"
                        style={{
                          background: 'linear-gradient(135deg, #10b981, #059669)',
                          border: 'none',
                          boxShadow: '0 8px 32px rgba(16, 185, 129, 0.3)',
                          opacity: isResuming ? 0.7 : 1
                        }}
                      >
                        {isResuming ? 'üîÑ Resuming...' : '‚ñ∂Ô∏è Resume from Checkpoint'}
                      </UltraButton>
                    </motion.div>
                  )}
                  
                  {/* Retry Button - Show for failed executions without checkpoint or if resume not available */}
                  {(executionData?.status === 'failed' || executionData?.error) && onRestart && !executionData?.execution_data?.resumable && (
                    <motion.div 
                      whileHover={{ scale: 1.05 }} 
                      whileTap={{ scale: 0.95 }}
                      initial={{ opacity: 0, x: 20 }}
                      animate={{ opacity: 1, x: 0 }}
                      transition={{ delay: 0.5 }}
                    >
                      <UltraButton
                        onClick={onRestart}
                        variant="primary"
                        icon={RefreshCw}
                        className="px-6 py-4 text-lg font-bold"
                        style={{
                          background: 'linear-gradient(135deg, #3b82f6, #1d4ed8)',
                          border: 'none',
                          boxShadow: '0 8px 32px rgba(59, 130, 246, 0.3)'
                        }}
                      >
                        Retry
                      </UltraButton>
                    </motion.div>
                  )}

                  {/* Completed State Actions */}
                  {executionData?.status === 'completed' && (
                    <>
                      {/* üëë FIXED: Edit Book Button */}
                      <motion.div 
                        whileHover={{ scale: 1.05 }} 
                        whileTap={{ scale: 0.95 }}
                        initial={{ opacity: 0, y: 20 }}
                        animate={{ opacity: 1, y: 0 }}
                        transition={{ delay: 0.4 }}
                      >
                        <UltraButton
                          onClick={() => {
                            const aggregatedData = getAggregatedContent(executionData);
                            if (!aggregatedData.html || aggregatedData.html.length < 100) {
                              toast.error('No substantial content found to edit.');
                              return;
                            }
                            setBookEditorData({
                              content: aggregatedData.html, // Pass the full compiled HTML
                              metadata: { title: aggregatedData.title },
                              structuredContent: aggregatedData, // Pass everything else for context
                              allFormats: aggregatedData.formats
                            });
                            setShowBookEditor(true);
                          }}
                          variant="secondary"
                          icon={Edit3}
                          className="px-6 py-4 text-lg font-bold"
                          style={{
                            background: 'linear-gradient(135deg, #8b5cf6, #6366f1)',
                            border: 'none',
                            boxShadow: '0 8px 32px rgba(139, 92, 246, 0.3)'
                          }}
                        >
                          Edit Book
                        </UltraButton>
                      </motion.div>
                      
                      {/* üëë FIXED: Single "Download Full Book" button */}
                      <motion.div 
                        whileHover={{ scale: 1.05 }} 
                        whileTap={{ scale: 0.95 }}
                        initial={{ opacity: 0, y: 20 }}
                        animate={{ opacity: 1, y: 0 }}
                        transition={{ delay: 0.5 }}
                      >
                        <UltraButton
                          onClick={publishAndDownloadBook}
                          variant="primary"
                          icon={isPublishing ? Loader2 : Download}
                          disabled={isPublishing}
                          className="px-8 py-4 text-lg font-bold"
                          style={{
                            background: 'linear-gradient(135deg, #10b981, #059669)',
                            border: 'none',
                            boxShadow: '0 8px 32px rgba(16, 185, 129, 0.3)'
                          }}
                        >
                          {isPublishing ? 'Publishing...' : 'Publish & Download'}
                        </UltraButton>
                      </motion.div>
                    </>
                  )}

                  {/* Close Button - Always available */}
                  <motion.div 
                    whileHover={{ scale: 1.05 }} 
                    whileTap={{ scale: 0.95 }}
                    initial={{ opacity: 0, y: 20 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ delay: 0.7 }}
                  >
                    <UltraButton
                      onClick={onClose}
                      variant="secondary"
                      icon={X}
                      className="px-6 py-4 text-lg font-bold"
                      style={{
                        background: 'linear-gradient(135deg, #6b7280, #4b5563)',
                        border: 'none',
                        boxShadow: '0 8px 32px rgba(107, 114, 128, 0.3)'
                      }}
                    >
                      Close
                    </UltraButton>
                  </motion.div>
                </div>
              </div>
            </div>
          </motion.div>
        </motion.div>
      )}
      
      {/* AI Thinking Modal */}
      <AIThinkingModal
        isOpen={showAIThinkingModal}
        onClose={() => setShowAIThinkingModal(false)}
        executionData={executionData}
        onForceStop={onForceStop}
        onRestart={onRestart}
      />
      
      {/* üëë FIXED: User Book Editor Modal */}
      <UserBookEditorModal
        isOpen={showBookEditor}
        onClose={() => setShowBookEditor(false)}
        bookData={bookEditorData}
        onSave={(updatedContent) => {
          console.log('üìö Book saved from editor!', updatedContent);
          // Here you would typically call a dbService to update the book
          toast.success('Book changes saved!');
          setShowBookEditor(false);
        }}
      />
    </AnimatePresence>
  )
  
}

export default UserExecutionModal
